{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './EventEmitter.js';\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\nexport const NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\n\nexport class NetworkManager extends EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    /*\n     * There are four possible orders of events:\n     *  A. `_onRequestWillBeSent`\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n     *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n     *     (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     *  A. `_onRequestWillBeSent`,\n     *     `_onRequestWillBeSent`, ...\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *     (see crbug.com/1196004)\n     */\n\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._requestIdToRequestPausedEvent = new Map();\n    this._requestIdToRequest = new Map();\n    this._extraHTTPHeaders = {};\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    this._emulatedNetworkConditions = {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    };\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  initialize() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this._client.send('Network.enable');\n      if (_this._ignoreHTTPSErrors) yield _this._client.send('Security.setIgnoreCertificateErrors', {\n        ignore: true\n      });\n    })();\n  }\n\n  authenticate(credentials) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._credentials = credentials;\n      yield _this2._updateProtocolRequestInterception();\n    })();\n  }\n\n  setExtraHTTPHeaders(extraHTTPHeaders) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3._extraHTTPHeaders = {};\n\n      for (const key of Object.keys(extraHTTPHeaders)) {\n        const value = extraHTTPHeaders[key];\n        assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n        _this3._extraHTTPHeaders[key.toLowerCase()] = value;\n      }\n\n      yield _this3._client.send('Network.setExtraHTTPHeaders', {\n        headers: _this3._extraHTTPHeaders\n      });\n    })();\n  }\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  setOfflineMode(value) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4._emulatedNetworkConditions.offline = value;\n      yield _this4._updateNetworkConditions();\n    })();\n  }\n\n  emulateNetworkConditions(networkConditions) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5._emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n      _this5._emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n      _this5._emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n      yield _this5._updateNetworkConditions();\n    })();\n  }\n\n  _updateNetworkConditions() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6._client.send('Network.emulateNetworkConditions', {\n        offline: _this6._emulatedNetworkConditions.offline,\n        latency: _this6._emulatedNetworkConditions.latency,\n        uploadThroughput: _this6._emulatedNetworkConditions.upload,\n        downloadThroughput: _this6._emulatedNetworkConditions.download\n      });\n    })();\n  }\n\n  setUserAgent(userAgent) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this7._client.send('Network.setUserAgentOverride', {\n        userAgent\n      });\n    })();\n  }\n\n  setCacheEnabled(enabled) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8._userCacheDisabled = !enabled;\n      yield _this8._updateProtocolCacheDisabled();\n    })();\n  }\n\n  setRequestInterception(value) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      _this9._userRequestInterceptionEnabled = value;\n      yield _this9._updateProtocolRequestInterception();\n    })();\n  }\n\n  _updateProtocolRequestInterception() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const enabled = _this10._userRequestInterceptionEnabled || !!_this10._credentials;\n      if (enabled === _this10._protocolRequestInterceptionEnabled) return;\n      _this10._protocolRequestInterceptionEnabled = enabled;\n\n      if (enabled) {\n        yield Promise.all([_this10._updateProtocolCacheDisabled(), _this10._client.send('Fetch.enable', {\n          handleAuthRequests: true,\n          patterns: [{\n            urlPattern: '*'\n          }]\n        })]);\n      } else {\n        yield Promise.all([_this10._updateProtocolCacheDisabled(), _this10._client.send('Fetch.disable')]);\n      }\n    })();\n  }\n\n  _cacheDisabled() {\n    return this._userCacheDisabled;\n  }\n\n  _updateProtocolCacheDisabled() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this11._client.send('Network.setCacheDisabled', {\n        cacheDisabled: _this11._cacheDisabled()\n      });\n    })();\n  }\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._userRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n\n      this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n\n      if (requestPausedEvent) {\n        const interceptionId = requestPausedEvent.requestId;\n\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToRequestPausedEvent.delete(requestId);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n\n  _onAuthRequired(event) {\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(debugError);\n  }\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (!requestId) {\n      return;\n    }\n\n    let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId); // redirect requests have the same `requestId`,\n\n\n    if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      requestWillBeSentEvent = null;\n    }\n\n    if (requestWillBeSentEvent) {\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToRequestPausedEvent.set(requestId, event);\n    }\n  }\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n  }\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n    this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n  }\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new HTTPResponse(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n\n    this._forgetRequest(request, false);\n\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new HTTPResponse(this._client, request, event.response);\n    request._response = response;\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n  }\n\n  _forgetRequest(request, events) {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n\n    this._requestIdToRequest.delete(requestId);\n\n    this._attemptedAuthentications.delete(interceptionId);\n\n    if (events) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      this._requestIdToRequestPausedEvent.delete(requestId);\n    }\n  }\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n\n} //# sourceMappingURL=NetworkManager.js.map","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/common/NetworkManager.js"],"names":["EventEmitter","assert","helper","debugError","HTTPRequest","HTTPResponse","NetworkManagerEmittedEvents","Request","Symbol","RequestServedFromCache","Response","RequestFailed","RequestFinished","NetworkManager","constructor","client","ignoreHTTPSErrors","frameManager","_requestIdToRequestWillBeSentEvent","Map","_requestIdToRequestPausedEvent","_requestIdToRequest","_extraHTTPHeaders","_credentials","_attemptedAuthentications","Set","_userRequestInterceptionEnabled","_protocolRequestInterceptionEnabled","_userCacheDisabled","_emulatedNetworkConditions","offline","upload","download","latency","_client","_ignoreHTTPSErrors","_frameManager","on","_onRequestPaused","bind","_onAuthRequired","_onRequestWillBeSent","_onRequestServedFromCache","_onResponseReceived","_onLoadingFinished","_onLoadingFailed","initialize","send","ignore","authenticate","credentials","_updateProtocolRequestInterception","setExtraHTTPHeaders","extraHTTPHeaders","key","Object","keys","value","isString","toLowerCase","headers","assign","setOfflineMode","_updateNetworkConditions","emulateNetworkConditions","networkConditions","uploadThroughput","downloadThroughput","setUserAgent","userAgent","setCacheEnabled","enabled","_updateProtocolCacheDisabled","setRequestInterception","Promise","all","handleAuthRequests","patterns","urlPattern","_cacheDisabled","cacheDisabled","event","request","url","startsWith","requestId","requestPausedEvent","get","set","interceptionId","_onRequest","delete","response","has","add","username","password","undefined","authChallengeResponse","catch","networkId","requestWillBeSentEvent","method","redirectChain","redirectResponse","_handleRequestRedirect","_redirectChain","frame","frameId","emit","_fromMemoryCache","responsePayload","_response","push","_resolveBody","Error","_forgetRequest","events","_requestId","_interceptionId","_failureText","errorText"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './EventEmitter.js';\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        /*\n         * There are four possible orders of events:\n         *  A. `_onRequestWillBeSent`\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n         *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n         *     (see crbug.com/1196004)\n         *\n         * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n         * optionally the `interceptionId` from `_onRequestPaused`.\n         *\n         * If request interception is disabled, call `_onRequest` once per call to\n         * `_onRequestWillBeSent`.\n         * If request interception is enabled, call `_onRequest` once per call to\n         * `_onRequestPaused` (once per `interceptionId`).\n         *\n         * Events are stored to allow for subsequent events to call `_onRequest`.\n         *\n         * Note that (chains of) redirect requests have the same `requestId` (!) as\n         * the original request. We have to anticipate series of events like these:\n         *  A. `_onRequestWillBeSent`,\n         *     `_onRequestWillBeSent`, ...\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *     (see crbug.com/1196004)\n         */\n        this._requestIdToRequestWillBeSentEvent = new Map();\n        this._requestIdToRequestPausedEvent = new Map();\n        this._requestIdToRequest = new Map();\n        this._extraHTTPHeaders = {};\n        this._credentials = null;\n        this._attemptedAuthentications = new Set();\n        this._userRequestInterceptionEnabled = false;\n        this._protocolRequestInterceptionEnabled = false;\n        this._userCacheDisabled = false;\n        this._emulatedNetworkConditions = {\n            offline: false,\n            upload: -1,\n            download: -1,\n            latency: 0,\n        };\n        this._client = client;\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._frameManager = frameManager;\n        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n    }\n    async initialize() {\n        await this._client.send('Network.enable');\n        if (this._ignoreHTTPSErrors)\n            await this._client.send('Security.setIgnoreCertificateErrors', {\n                ignore: true,\n            });\n    }\n    async authenticate(credentials) {\n        this._credentials = credentials;\n        await this._updateProtocolRequestInterception();\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        this._extraHTTPHeaders = {};\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            this._extraHTTPHeaders[key.toLowerCase()] = value;\n        }\n        await this._client.send('Network.setExtraHTTPHeaders', {\n            headers: this._extraHTTPHeaders,\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, this._extraHTTPHeaders);\n    }\n    async setOfflineMode(value) {\n        this._emulatedNetworkConditions.offline = value;\n        await this._updateNetworkConditions();\n    }\n    async emulateNetworkConditions(networkConditions) {\n        this._emulatedNetworkConditions.upload = networkConditions\n            ? networkConditions.upload\n            : -1;\n        this._emulatedNetworkConditions.download = networkConditions\n            ? networkConditions.download\n            : -1;\n        this._emulatedNetworkConditions.latency = networkConditions\n            ? networkConditions.latency\n            : 0;\n        await this._updateNetworkConditions();\n    }\n    async _updateNetworkConditions() {\n        await this._client.send('Network.emulateNetworkConditions', {\n            offline: this._emulatedNetworkConditions.offline,\n            latency: this._emulatedNetworkConditions.latency,\n            uploadThroughput: this._emulatedNetworkConditions.upload,\n            downloadThroughput: this._emulatedNetworkConditions.download,\n        });\n    }\n    async setUserAgent(userAgent) {\n        await this._client.send('Network.setUserAgentOverride', { userAgent });\n    }\n    async setCacheEnabled(enabled) {\n        this._userCacheDisabled = !enabled;\n        await this._updateProtocolCacheDisabled();\n    }\n    async setRequestInterception(value) {\n        this._userRequestInterceptionEnabled = value;\n        await this._updateProtocolRequestInterception();\n    }\n    async _updateProtocolRequestInterception() {\n        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n        if (enabled === this._protocolRequestInterceptionEnabled)\n            return;\n        this._protocolRequestInterceptionEnabled = enabled;\n        if (enabled) {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.enable', {\n                    handleAuthRequests: true,\n                    patterns: [{ urlPattern: '*' }],\n                }),\n            ]);\n        }\n        else {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.disable'),\n            ]);\n        }\n    }\n    _cacheDisabled() {\n        return this._userCacheDisabled;\n    }\n    async _updateProtocolCacheDisabled() {\n        await this._client.send('Network.setCacheDisabled', {\n            cacheDisabled: this._cacheDisabled(),\n        });\n    }\n    _onRequestWillBeSent(event) {\n        // Request interception doesn't happen for data URLs with Network Service.\n        if (this._userRequestInterceptionEnabled &&\n            !event.request.url.startsWith('data:')) {\n            const requestId = event.requestId;\n            const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n            this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n            if (requestPausedEvent) {\n                const interceptionId = requestPausedEvent.requestId;\n                this._onRequest(event, interceptionId);\n                this._requestIdToRequestPausedEvent.delete(requestId);\n            }\n            return;\n        }\n        this._onRequest(event, null);\n    }\n    _onAuthRequired(event) {\n        let response = 'Default';\n        if (this._attemptedAuthentications.has(event.requestId)) {\n            response = 'CancelAuth';\n        }\n        else if (this._credentials) {\n            response = 'ProvideCredentials';\n            this._attemptedAuthentications.add(event.requestId);\n        }\n        const { username, password } = this._credentials || {\n            username: undefined,\n            password: undefined,\n        };\n        this._client\n            .send('Fetch.continueWithAuth', {\n            requestId: event.requestId,\n            authChallengeResponse: { response, username, password },\n        })\n            .catch(debugError);\n    }\n    _onRequestPaused(event) {\n        if (!this._userRequestInterceptionEnabled &&\n            this._protocolRequestInterceptionEnabled) {\n            this._client\n                .send('Fetch.continueRequest', {\n                requestId: event.requestId,\n            })\n                .catch(debugError);\n        }\n        const requestId = event.networkId;\n        const interceptionId = event.requestId;\n        if (!requestId) {\n            return;\n        }\n        let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n        // redirect requests have the same `requestId`,\n        if (requestWillBeSentEvent &&\n            (requestWillBeSentEvent.request.url !== event.request.url ||\n                requestWillBeSentEvent.request.method !== event.request.method)) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            requestWillBeSentEvent = null;\n        }\n        if (requestWillBeSentEvent) {\n            this._onRequest(requestWillBeSentEvent, interceptionId);\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n        }\n        else {\n            this._requestIdToRequestPausedEvent.set(requestId, event);\n        }\n    }\n    _onRequest(event, interceptionId) {\n        let redirectChain = [];\n        if (event.redirectResponse) {\n            const request = this._requestIdToRequest.get(event.requestId);\n            // If we connect late to the target, we could have missed the\n            // requestWillBeSent event.\n            if (request) {\n                this._handleRequestRedirect(request, event.redirectResponse);\n                redirectChain = request._redirectChain;\n            }\n        }\n        const frame = event.frameId\n            ? this._frameManager.frame(event.frameId)\n            : null;\n        const request = new HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n        this._requestIdToRequest.set(event.requestId, request);\n        this.emit(NetworkManagerEmittedEvents.Request, request);\n    }\n    _onRequestServedFromCache(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        if (request)\n            request._fromMemoryCache = true;\n        this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n    }\n    _handleRequestRedirect(request, responsePayload) {\n        const response = new HTTPResponse(this._client, request, responsePayload);\n        request._response = response;\n        request._redirectChain.push(request);\n        response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n        this._forgetRequest(request, false);\n        this.emit(NetworkManagerEmittedEvents.Response, response);\n        this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onResponseReceived(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // FileUpload sends a response without a matching request.\n        if (!request)\n            return;\n        const response = new HTTPResponse(this._client, request, event.response);\n        request._response = response;\n        this.emit(NetworkManagerEmittedEvents.Response, response);\n    }\n    _forgetRequest(request, events) {\n        const requestId = request._requestId;\n        const interceptionId = request._interceptionId;\n        this._requestIdToRequest.delete(requestId);\n        this._attemptedAuthentications.delete(interceptionId);\n        if (events) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            this._requestIdToRequestPausedEvent.delete(requestId);\n        }\n    }\n    _onLoadingFinished(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        // Under certain conditions we never get the Network.responseReceived\n        // event from protocol. @see https://crbug.com/883475\n        if (request.response())\n            request.response()._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onLoadingFailed(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        request._failureText = event.errorText;\n        const response = request.response();\n        if (response)\n            response._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n    }\n}\n//# sourceMappingURL=NetworkManager.js.map"]},"metadata":{},"sourceType":"module"}