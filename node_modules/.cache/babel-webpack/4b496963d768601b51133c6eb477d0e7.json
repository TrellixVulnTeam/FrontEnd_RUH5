{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from './Browser.js';\nimport { assert } from './assert.js';\nimport { debugError } from '../common/helper.js';\nimport { Connection } from './Connection.js';\nimport { getFetch } from './fetch.js';\nimport { isNode } from '../environment.js';\n\nconst getWebSocketTransportClass = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    return isNode ? (yield import('../node/NodeWebSocketTransport.js')).NodeWebSocketTransport : (yield import('./BrowserWebSocketTransport.js')).BrowserWebSocketTransport;\n  });\n\n  return function getWebSocketTransportClass() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Users should never call this directly; it's called when calling\n * `puppeteer.connect`.\n * @internal\n */\n\n\nexport const connectToBrowser = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (options) {\n    const {\n      browserWSEndpoint,\n      browserURL,\n      ignoreHTTPSErrors = false,\n      defaultViewport = {\n        width: 800,\n        height: 600\n      },\n      transport,\n      slowMo = 0,\n      targetFilter\n    } = options;\n    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');\n    let connection = null;\n\n    if (transport) {\n      connection = new Connection('', transport, slowMo);\n    } else if (browserWSEndpoint) {\n      const WebSocketClass = yield getWebSocketTransportClass();\n      const connectionTransport = yield WebSocketClass.create(browserWSEndpoint);\n      connection = new Connection(browserWSEndpoint, connectionTransport, slowMo);\n    } else if (browserURL) {\n      const connectionURL = yield getWSEndpoint(browserURL);\n      const WebSocketClass = yield getWebSocketTransportClass();\n      const connectionTransport = yield WebSocketClass.create(connectionURL);\n      connection = new Connection(connectionURL, connectionTransport, slowMo);\n    }\n\n    const {\n      browserContextIds\n    } = yield connection.send('Target.getBrowserContexts');\n    return Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send('Browser.close').catch(debugError), targetFilter);\n  });\n\n  return function connectToBrowser(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nfunction getWSEndpoint(_x2) {\n  return _getWSEndpoint.apply(this, arguments);\n} //# sourceMappingURL=BrowserConnector.js.map\n\n\nfunction _getWSEndpoint() {\n  _getWSEndpoint = _asyncToGenerator(function* (browserURL) {\n    const endpointURL = new URL('/json/version', browserURL);\n    const fetch = yield getFetch();\n\n    try {\n      const result = yield fetch(endpointURL.toString(), {\n        method: 'GET'\n      });\n\n      if (!result.ok) {\n        throw new Error(`HTTP ${result.statusText}`);\n      }\n\n      const data = yield result.json();\n      return data.webSocketDebuggerUrl;\n    } catch (error) {\n      error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;\n      throw error;\n    }\n  });\n  return _getWSEndpoint.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/common/BrowserConnector.js"],"names":["Browser","assert","debugError","Connection","getFetch","isNode","getWebSocketTransportClass","NodeWebSocketTransport","BrowserWebSocketTransport","connectToBrowser","options","browserWSEndpoint","browserURL","ignoreHTTPSErrors","defaultViewport","width","height","transport","slowMo","targetFilter","Number","connection","WebSocketClass","connectionTransport","create","connectionURL","getWSEndpoint","browserContextIds","send","catch","endpointURL","URL","fetch","result","toString","method","ok","Error","statusText","data","json","webSocketDebuggerUrl","error","message"],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from './Browser.js';\nimport { assert } from './assert.js';\nimport { debugError } from '../common/helper.js';\nimport { Connection } from './Connection.js';\nimport { getFetch } from './fetch.js';\nimport { isNode } from '../environment.js';\nconst getWebSocketTransportClass = async () => {\n    return isNode\n        ? (await import('../node/NodeWebSocketTransport.js')).NodeWebSocketTransport\n        : (await import('./BrowserWebSocketTransport.js'))\n            .BrowserWebSocketTransport;\n};\n/**\n * Users should never call this directly; it's called when calling\n * `puppeteer.connect`.\n * @internal\n */\nexport const connectToBrowser = async (options) => {\n    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, slowMo = 0, targetFilter, } = options;\n    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===\n        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');\n    let connection = null;\n    if (transport) {\n        connection = new Connection('', transport, slowMo);\n    }\n    else if (browserWSEndpoint) {\n        const WebSocketClass = await getWebSocketTransportClass();\n        const connectionTransport = await WebSocketClass.create(browserWSEndpoint);\n        connection = new Connection(browserWSEndpoint, connectionTransport, slowMo);\n    }\n    else if (browserURL) {\n        const connectionURL = await getWSEndpoint(browserURL);\n        const WebSocketClass = await getWebSocketTransportClass();\n        const connectionTransport = await WebSocketClass.create(connectionURL);\n        connection = new Connection(connectionURL, connectionTransport, slowMo);\n    }\n    const { browserContextIds } = await connection.send('Target.getBrowserContexts');\n    return Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send('Browser.close').catch(debugError), targetFilter);\n};\nasync function getWSEndpoint(browserURL) {\n    const endpointURL = new URL('/json/version', browserURL);\n    const fetch = await getFetch();\n    try {\n        const result = await fetch(endpointURL.toString(), {\n            method: 'GET',\n        });\n        if (!result.ok) {\n            throw new Error(`HTTP ${result.statusText}`);\n        }\n        const data = await result.json();\n        return data.webSocketDebuggerUrl;\n    }\n    catch (error) {\n        error.message =\n            `Failed to fetch browser webSocket URL from ${endpointURL}: ` +\n                error.message;\n        throw error;\n    }\n}\n//# sourceMappingURL=BrowserConnector.js.map"]},"metadata":{},"sourceType":"module"}