{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { debug } from '../common/Debug.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { ExecutionContext, EVALUATION_SCRIPT_URL } from './ExecutionContext.js';\nimport { LifecycleWatcher } from './LifecycleWatcher.js';\nimport { DOMWorld } from './DOMWorld.js';\nimport { NetworkManager } from './NetworkManager.js';\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\nexport const FrameManagerEmittedEvents = {\n  FrameAttached: Symbol('FrameManager.FrameAttached'),\n  FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n  FrameDetached: Symbol('FrameManager.FrameDetached'),\n  LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n  FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n  ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n  ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed')\n};\n/**\n * @internal\n */\n\nexport class FrameManager extends EventEmitter {\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    var _this;\n\n    super();\n    _this = this;\n    this._frames = new Map();\n    this._contextIdToContext = new Map();\n    this._isolatedWorlds = new Set();\n    this._client = client;\n    this._page = page;\n    this._networkManager = new NetworkManager(client, ignoreHTTPSErrors, this);\n    this._timeoutSettings = timeoutSettings;\n\n    this._client.on('Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId));\n\n    this._client.on('Page.frameNavigated', event => this._onFrameNavigated(event.frame));\n\n    this._client.on('Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url));\n\n    this._client.on('Page.frameDetached', event => this._onFrameDetached(event.frameId));\n\n    this._client.on('Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId));\n\n    this._client.on('Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context));\n\n    this._client.on('Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId));\n\n    this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());\n\n    this._client.on('Page.lifecycleEvent', event => this._onLifecycleEvent(event));\n\n    this._client.on('Target.attachedToTarget', /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (event) {\n        return _this._onFrameMoved(event);\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  initialize() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield Promise.all([_this2._client.send('Page.enable'), _this2._client.send('Page.getFrameTree')]);\n      const {\n        frameTree\n      } = result[1];\n\n      _this2._handleFrameTree(frameTree);\n\n      yield Promise.all([_this2._client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), _this2._client.send('Runtime.enable').then(() => _this2._ensureIsolatedWorld(UTILITY_WORLD_NAME)), _this2._networkManager.initialize()]);\n    })();\n  }\n\n  networkManager() {\n    return this._networkManager;\n  }\n\n  navigateFrame(frame, url, options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      assertNoLegacyNavigationOptions(options);\n      const {\n        referer = _this3._networkManager.extraHTTPHeaders()['referer'],\n        waitUntil = ['load'],\n        timeout = _this3._timeoutSettings.navigationTimeout()\n      } = options;\n      const watcher = new LifecycleWatcher(_this3, frame, waitUntil, timeout);\n      let ensureNewDocumentNavigation = false;\n      let error = yield Promise.race([navigate(_this3._client, url, referer, frame._id), watcher.timeoutOrTerminationPromise()]);\n\n      if (!error) {\n        error = yield Promise.race([watcher.timeoutOrTerminationPromise(), ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()]);\n      }\n\n      watcher.dispose();\n      if (error) throw error;\n      return watcher.navigationResponse();\n\n      function navigate(_x2, _x3, _x4, _x5) {\n        return _navigate.apply(this, arguments);\n      }\n\n      function _navigate() {\n        _navigate = _asyncToGenerator(function* (client, url, referrer, frameId) {\n          try {\n            const response = yield client.send('Page.navigate', {\n              url,\n              referrer,\n              frameId\n            });\n            ensureNewDocumentNavigation = !!response.loaderId;\n            return response.errorText ? new Error(`${response.errorText} at ${url}`) : null;\n          } catch (error) {\n            return error;\n          }\n        });\n        return _navigate.apply(this, arguments);\n      }\n    })();\n  }\n\n  waitForFrameNavigation(frame, options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      assertNoLegacyNavigationOptions(options);\n      const {\n        waitUntil = ['load'],\n        timeout = _this4._timeoutSettings.navigationTimeout()\n      } = options;\n      const watcher = new LifecycleWatcher(_this4, frame, waitUntil, timeout);\n      const error = yield Promise.race([watcher.timeoutOrTerminationPromise(), watcher.sameDocumentNavigationPromise(), watcher.newDocumentNavigationPromise()]);\n      watcher.dispose();\n      if (error) throw error;\n      return watcher.navigationResponse();\n    })();\n  }\n\n  _onFrameMoved(event) {\n    return _asyncToGenerator(function* () {\n      if (event.targetInfo.type !== 'iframe') {\n        return;\n      } // TODO(sadym): Remove debug message once proper OOPIF support is\n      // implemented: https://github.com/puppeteer/puppeteer/issues/2548\n\n\n      debug('puppeteer:frame')(`The frame '${event.targetInfo.targetId}' moved to another session. ` + `Out-of-process iframes (OOPIF) are not supported by Puppeteer yet. ` + `https://github.com/puppeteer/puppeteer/issues/2548`);\n    })();\n  }\n\n  _onLifecycleEvent(event) {\n    const frame = this._frames.get(event.frameId);\n\n    if (!frame) return;\n\n    frame._onLifecycleEvent(event.loaderId, event.name);\n\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _onFrameStoppedLoading(frameId) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._onLoadingStopped();\n\n    this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _handleFrameTree(frameTree) {\n    if (frameTree.frame.parentId) this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);\n\n    this._onFrameNavigated(frameTree.frame);\n\n    if (!frameTree.childFrames) return;\n\n    for (const child of frameTree.childFrames) this._handleFrameTree(child);\n  }\n\n  page() {\n    return this._page;\n  }\n\n  mainFrame() {\n    return this._mainFrame;\n  }\n\n  frames() {\n    return Array.from(this._frames.values());\n  }\n\n  frame(frameId) {\n    return this._frames.get(frameId) || null;\n  }\n\n  _onFrameAttached(frameId, parentFrameId) {\n    if (this._frames.has(frameId)) return;\n    assert(parentFrameId);\n\n    const parentFrame = this._frames.get(parentFrameId);\n\n    const frame = new Frame(this, parentFrame, frameId);\n\n    this._frames.set(frame._id, frame);\n\n    this.emit(FrameManagerEmittedEvents.FrameAttached, frame);\n  }\n\n  _onFrameNavigated(framePayload) {\n    const isMainFrame = !framePayload.parentId;\n    let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);\n    assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame'); // Detach all child frames first.\n\n    if (frame) {\n      for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n    } // Update or create main frame.\n\n\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(frame._id);\n\n        frame._id = framePayload.id;\n      } else {\n        // Initial main frame navigation.\n        frame = new Frame(this, null, framePayload.id);\n      }\n\n      this._frames.set(framePayload.id, frame);\n\n      this._mainFrame = frame;\n    } // Update frame payload.\n\n\n    frame._navigated(framePayload);\n\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  _ensureIsolatedWorld(name) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this5._isolatedWorlds.has(name)) return;\n\n      _this5._isolatedWorlds.add(name);\n\n      yield _this5._client.send('Page.addScriptToEvaluateOnNewDocument', {\n        source: `//# sourceURL=${EVALUATION_SCRIPT_URL}`,\n        worldName: name\n      }); // Frames might be removed before we send this.\n\n      yield Promise.all(_this5.frames().map(frame => _this5._client.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(debugError)));\n    })();\n  }\n\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._navigatedWithinDocument(url);\n\n    this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n    this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  _onFrameDetached(frameId) {\n    const frame = this._frames.get(frameId);\n\n    if (frame) this._removeFramesRecursively(frame);\n  }\n\n  _onExecutionContextCreated(contextPayload) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData ? auxData.frameId : null;\n    const frame = this._frames.get(frameId) || null;\n    let world = null;\n\n    if (frame) {\n      if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n        world = frame._mainWorld;\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame._secondaryWorld._hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame._secondaryWorld;\n      }\n    }\n\n    const context = new ExecutionContext(this._client, contextPayload, world);\n    if (world) world._setContext(context);\n\n    this._contextIdToContext.set(contextPayload.id, context);\n  }\n\n  _onExecutionContextDestroyed(executionContextId) {\n    const context = this._contextIdToContext.get(executionContextId);\n\n    if (!context) return;\n\n    this._contextIdToContext.delete(executionContextId);\n\n    if (context._world) context._world._setContext(null);\n  }\n\n  _onExecutionContextsCleared() {\n    for (const context of this._contextIdToContext.values()) {\n      if (context._world) context._world._setContext(null);\n    }\n\n    this._contextIdToContext.clear();\n  }\n\n  executionContextById(contextId) {\n    const context = this._contextIdToContext.get(contextId);\n\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  _removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n\n    frame._detach();\n\n    this._frames.delete(frame._id);\n\n    this.emit(FrameManagerEmittedEvents.FrameDetached, frame);\n  }\n\n}\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\n\nexport class Frame {\n  /**\n   * @internal\n   */\n  constructor(frameManager, parentFrame, frameId) {\n    this._url = '';\n    this._detached = false;\n    /**\n     * @internal\n     */\n\n    this._loaderId = '';\n    /**\n     * @internal\n     */\n\n    this._lifecycleEvents = new Set();\n    this._frameManager = frameManager;\n    this._parentFrame = parentFrame;\n    this._url = '';\n    this._id = frameId;\n    this._detached = false;\n    this._loaderId = '';\n    this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);\n    this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);\n    this._childFrames = new Set();\n    if (this._parentFrame) this._parentFrame._childFrames.add(this);\n  }\n  /**\n   * @remarks\n   *\n   * `frame.goto` will throw an error if:\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   *\n   * - target URL is invalid.\n   *\n   * - the `timeout` is exceeded during navigation.\n   *\n   * - the remote server does not respond or is unreachable.\n   *\n   * - the main resource failed to load.\n   *\n   * `frame.goto` will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\".  The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   *\n   * NOTE: `frame.goto` either throws an error or returns a main resource\n   * response. The only exceptions are navigation to `about:blank` or\n   * navigation to the same URL with a different hash, which would succeed and\n   * return `null`.\n   *\n   * NOTE: Headless mode doesn't support navigation to a PDF document. See\n   * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * @param url - the URL to navigate the frame to. This should include the\n   * scheme, e.g. `https://`.\n   * @param options - navigation options. `waitUntil` is useful to define when\n   * the navigation should be considered successful - see the docs for\n   * {@link PuppeteerLifeCycleEvent} for more details.\n   *\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n\n\n  goto(url, options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this6._frameManager.navigateFrame(_this6, url, options);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * This resolves when the frame navigates to a new URL. It is useful for when\n   * you run code which will indirectly cause the frame to navigate. Consider\n   * this example:\n   *\n   * ```js\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n   *\n   * @param options - options to configure when the navigation is consided finished.\n   * @returns a promise that resolves when the frame navigates to a new URL.\n   */\n\n\n  waitForNavigation(options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this7._frameManager.waitForFrameNavigation(_this7, options);\n    })();\n  }\n  /**\n   * @returns a promise that resolves to the frame's default execution context.\n   */\n\n\n  executionContext() {\n    return this._mainWorld.executionContext();\n  }\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Frame.evaluate} and\n   * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * This method behaves identically to {@link Page.evaluateHandle} except it's\n   * run within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  evaluateHandle(pageFunction, ...args) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this8._mainWorld.evaluateHandle(pageFunction, ...args);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves identically to {@link Page.evaluate} except it's run\n   * within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  evaluate(pageFunction, ...args) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this9._mainWorld.evaluate(pageFunction, ...args);\n    })();\n  }\n  /**\n   * This method queries the frame for the given selector.\n   *\n   * @param selector - a selector to query for.\n   * @returns A promise which resolves to an `ElementHandle` pointing at the\n   * element, or `null` if it was not found.\n   */\n\n\n  $(selector) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this10._mainWorld.$(selector);\n    })();\n  }\n  /**\n   * This method evaluates the given XPath expression and returns the results.\n   *\n   * @param expression - the XPath expression to evaluate.\n   */\n\n\n  $x(expression) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this11._mainWorld.$x(expression);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `document.querySelector` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  $eval(selector, pageFunction, ...args) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this12._mainWorld.$eval(selector, pageFunction, ...args);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  $$eval(selector, pageFunction, ...args) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this13._mainWorld.$$eval(selector, pageFunction, ...args);\n    })();\n  }\n  /**\n   * This runs `document.querySelectorAll` in the frame and returns the result.\n   *\n   * @param selector - a selector to search for\n   * @returns An array of element handles pointing to the found frame elements.\n   */\n\n\n  $$(selector) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this14._mainWorld.$$(selector);\n    })();\n  }\n  /**\n   * @returns the full HTML contents of the frame, including the doctype.\n   */\n\n\n  content() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this15._secondaryWorld.content();\n    })();\n  }\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n\n\n  setContent(html, options = {}) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this16._secondaryWorld.setContent(html, options);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * Note: This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   *\n   * @returns the frame's `name` attribute as specified in the tag.\n   */\n\n\n  name() {\n    return this._name || '';\n  }\n  /**\n   * @returns the frame's URL.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n   */\n\n\n  parentFrame() {\n    return this._parentFrame;\n  }\n  /**\n   * @returns an array of child frames.\n   */\n\n\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n  /**\n   * @returns `true` if the frame has been detached, or `false` otherwise.\n   */\n\n\n  isDetached() {\n    return this._detached;\n  }\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - configure the script to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the script's\n   * `onload` event fires or when the script content was injected into the\n   * frame.\n   */\n\n\n  addScriptTag(options) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this17._mainWorld.addScriptTag(options);\n    })();\n  }\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * @param options - configure the CSS to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the stylesheets's\n   * `onload` event fires or when the CSS content was injected into the\n   * frame.\n   */\n\n\n  addStyleTag(options) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this18._mainWorld.addStyleTag(options);\n    })();\n  }\n  /**\n   *\n   * This method clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   *\n   * This method scrolls the element into view if needed, and then uses\n   * {@link Page.mouse} to click in the center of the element. If there's no\n   * element matching `selector`, the method throws an error.\n   *\n   * Bear in mind that if `click()` triggers a navigation event and there's a\n   * separate `page.waitForNavigation()` promise to be resolved, you may end up\n   * with a race condition that yields unexpected results. The correct pattern\n   * for click and wait for navigation is the following:\n   *\n   * ```javascript\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   * @param selector - the selector to search for to click. If there are\n   * multiple elements, the first will be clicked.\n   */\n\n\n  click(selector, options = {}) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this19._secondaryWorld.click(selector, options);\n    })();\n  }\n  /**\n   * This method fetches an element with `selector` and focuses it.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector for the element to focus. If there are\n   * multiple elements, the first will be focused.\n   */\n\n\n  focus(selector) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this20._secondaryWorld.focus(selector);\n    })();\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse} to hover over the center of the\n   * element.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an\n   *\n   * @param selector - the selector for the element to hover. If there are\n   * multiple elements, the first will be hovered.\n   */\n\n\n  hover(selector) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this21._secondaryWorld.hover(selector);\n    })();\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have\n   * been selected.\n   *\n   * @remarks\n   *\n   * If there's no `<select>` element matching `selector`, the\n   * method throws an error.\n   *\n   * @example\n   * ```js\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - a selector to query the frame for\n   * @param values - an array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   */\n\n\n  select(selector, ...values) {\n    return this._secondaryWorld.select(selector, ...values);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n   * element.\n   *\n   * @remarks\n   *\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector to tap.\n   * @returns a promise that resolves when the element has been tapped.\n   */\n\n\n  tap(selector) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this22._secondaryWorld.tap(selector);\n    })();\n  }\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   * ```js\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   *\n   * @returns a promise that resolves when the typing is complete.\n   */\n\n\n  type(selector, text, options) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this23._mainWorld.type(selector, text, options);\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves differently depending on the first parameter. If it's a\n   * `string`, it will be treated as a `selector` or `xpath` (if the string\n   * starts with `//`). This method then is a shortcut for\n   * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n   *\n   * If the first argument is a function this method is a shortcut for\n   * {@link Frame.waitForFunction}.\n   *\n   * If the first argument is a `number`, it's treated as a timeout in\n   * milliseconds and the method returns a promise which resolves after the\n   * timeout.\n   *\n   * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n   * wait for.\n   * @param options - optional waiting parameters.\n   * @param args - arguments to pass to `pageFunction`.\n   *\n   * @deprecated Don't use this method directly. Instead use the more explicit\n   * methods available: {@link Frame.waitForSelector},\n   * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n   * {@link Frame.waitForTimeout}.\n   */\n\n\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    const xPathPattern = '//';\n    console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n\n    if (helper.isString(selectorOrFunctionOrTimeout)) {\n      const string = selectorOrFunctionOrTimeout;\n      if (string.startsWith(xPathPattern)) return this.waitForXPath(string, options);\n      return this.waitForSelector(string, options);\n    }\n\n    if (helper.isNumber(selectorOrFunctionOrTimeout)) return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n    if (typeof selectorOrFunctionOrTimeout === 'function') return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n    return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n  }\n  /**\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n\n\n  waitForTimeout(milliseconds) {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n  /**\n   * @remarks\n   *\n   *\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately.\n   * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n   * the function will throw.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page.mainFrame()\n   *   .waitForSelector('img')\n   *   .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   * @param selector - the selector to wait for.\n   * @param options - options to define if the element should be visible and how\n   * long to wait before timing out.\n   * @returns a promise which resolves when an element matching the selector\n   * string is added to the DOM.\n   */\n\n\n  waitForSelector(selector, options = {}) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this24._secondaryWorld.waitForSelector(selector, options);\n      if (!handle) return null;\n      const mainExecutionContext = yield _this24._mainWorld.executionContext();\n      const result = yield mainExecutionContext._adoptElementHandle(handle);\n      yield handle.dispose();\n      return result;\n    })();\n  }\n  /**\n   * @remarks\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options  - options to configure the visiblity of the element and how\n   * long to wait before timing out.\n   */\n\n\n  waitForXPath(xpath, options = {}) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this25._secondaryWorld.waitForXPath(xpath, options);\n      if (!handle) return null;\n      const mainExecutionContext = yield _this25._mainWorld.executionContext();\n      const result = yield mainExecutionContext._adoptElementHandle(handle);\n      yield handle.dispose();\n      return result;\n    })();\n  }\n  /**\n   * @remarks\n   *\n   * @example\n   *\n   * The `waitForFunction` can be used to observe viewport size change:\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```js\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   *);\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n  }\n  /**\n   * @returns the frame's title.\n   */\n\n\n  title() {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this26._secondaryWorld.title();\n    })();\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigated(framePayload) {\n    this._name = framePayload.name;\n    this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigatedWithinDocument(url) {\n    this._url = url;\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLifecycleEvent(loaderId, name) {\n    if (name === 'init') {\n      this._loaderId = loaderId;\n\n      this._lifecycleEvents.clear();\n    }\n\n    this._lifecycleEvents.add(name);\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLoadingStopped() {\n    this._lifecycleEvents.add('DOMContentLoaded');\n\n    this._lifecycleEvents.add('load');\n  }\n  /**\n   * @internal\n   */\n\n\n  _detach() {\n    this._detached = true;\n\n    this._mainWorld._detach();\n\n    this._secondaryWorld._detach();\n\n    if (this._parentFrame) this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n\n}\n\nfunction assertNoLegacyNavigationOptions(options) {\n  assert(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n  assert(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n  assert(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n} //# sourceMappingURL=FrameManager.js.map","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/common/FrameManager.js"],"names":["debug","EventEmitter","assert","helper","debugError","ExecutionContext","EVALUATION_SCRIPT_URL","LifecycleWatcher","DOMWorld","NetworkManager","UTILITY_WORLD_NAME","FrameManagerEmittedEvents","FrameAttached","Symbol","FrameNavigated","FrameDetached","LifecycleEvent","FrameNavigatedWithinDocument","ExecutionContextCreated","ExecutionContextDestroyed","FrameManager","constructor","client","page","ignoreHTTPSErrors","timeoutSettings","_frames","Map","_contextIdToContext","_isolatedWorlds","Set","_client","_page","_networkManager","_timeoutSettings","on","event","_onFrameAttached","frameId","parentFrameId","_onFrameNavigated","frame","_onFrameNavigatedWithinDocument","url","_onFrameDetached","_onFrameStoppedLoading","_onExecutionContextCreated","context","_onExecutionContextDestroyed","executionContextId","_onExecutionContextsCleared","_onLifecycleEvent","_onFrameMoved","initialize","result","Promise","all","send","frameTree","_handleFrameTree","enabled","then","_ensureIsolatedWorld","networkManager","navigateFrame","options","assertNoLegacyNavigationOptions","referer","extraHTTPHeaders","waitUntil","timeout","navigationTimeout","watcher","ensureNewDocumentNavigation","error","race","navigate","_id","timeoutOrTerminationPromise","newDocumentNavigationPromise","sameDocumentNavigationPromise","dispose","navigationResponse","referrer","response","loaderId","errorText","Error","waitForFrameNavigation","targetInfo","type","targetId","get","name","emit","_onLoadingStopped","parentId","id","childFrames","child","mainFrame","_mainFrame","frames","Array","from","values","has","parentFrame","Frame","set","framePayload","isMainFrame","_removeFramesRecursively","delete","_navigated","add","source","worldName","map","grantUniveralAccess","catch","_navigatedWithinDocument","contextPayload","auxData","world","_mainWorld","_secondaryWorld","_hasContext","_setContext","_world","clear","executionContextById","contextId","_detach","frameManager","_url","_detached","_loaderId","_lifecycleEvents","_frameManager","_parentFrame","_childFrames","goto","waitForNavigation","executionContext","evaluateHandle","pageFunction","args","evaluate","$","selector","$x","expression","$eval","$$eval","$$","content","setContent","html","_name","isDetached","addScriptTag","addStyleTag","click","focus","hover","select","tap","text","waitFor","selectorOrFunctionOrTimeout","xPathPattern","console","warn","isString","string","startsWith","waitForXPath","waitForSelector","isNumber","fulfill","setTimeout","waitForFunction","reject","waitForTimeout","milliseconds","resolve","handle","mainExecutionContext","_adoptElementHandle","xpath","title","urlFragment","undefined"],"mappings":"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;AAAA;;AAAA;AACvB,aAAO,OAAI,CAAC4D,UAAL,CAAgBqC,WAAhB,CAA4BjG,OAA5B,CAAP;AADuB;AAE1B;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUkG,EAAAA,KAAK,CAACb,QAAD,EAAWrF,OAAO,GAAG,EAArB,EAAyB;AAAA;;AAAA;AAChC,aAAO,OAAI,CAAC6D,eAAL,CAAqBqC,KAArB,CAA2Bb,QAA3B,EAAqCrF,OAArC,CAAP;AADgC;AAEnC;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUmG,EAAAA,KAAK,CAACd,QAAD,EAAW;AAAA;;AAAA;AAClB,aAAO,OAAI,CAACxB,eAAL,CAAqBsC,KAArB,CAA2Bd,QAA3B,CAAP;AADkB;AAErB;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUe,EAAAA,KAAK,CAACf,QAAD,EAAW;AAAA;;AAAA;AAClB,aAAO,OAAI,CAACxB,eAAL,CAAqBuC,KAArB,CAA2Bf,QAA3B,CAAP;AADkB;AAErB;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIgB,EAAAA,MAAM,CAAChB,QAAD,EAAW,GAAG7C,MAAd,EAAsB;AACxB,WAAO,KAAKqB,eAAL,CAAqBwC,MAArB,CAA4BhB,QAA5B,EAAsC,GAAG7C,MAAzC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU8D,EAAAA,GAAG,CAACjB,QAAD,EAAW;AAAA;;AAAA;AAChB,aAAO,OAAI,CAACxB,eAAL,CAAqByC,GAArB,CAAyBjB,QAAzB,CAAP;AADgB;AAEnB;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { debug } from '../common/Debug.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { ExecutionContext, EVALUATION_SCRIPT_URL } from './ExecutionContext.js';\nimport { LifecycleWatcher, } from './LifecycleWatcher.js';\nimport { DOMWorld } from './DOMWorld.js';\nimport { NetworkManager } from './NetworkManager.js';\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const FrameManagerEmittedEvents = {\n    FrameAttached: Symbol('FrameManager.FrameAttached'),\n    FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n    FrameDetached: Symbol('FrameManager.FrameDetached'),\n    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n    ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n    ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),\n};\n/**\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n        super();\n        this._frames = new Map();\n        this._contextIdToContext = new Map();\n        this._isolatedWorlds = new Set();\n        this._client = client;\n        this._page = page;\n        this._networkManager = new NetworkManager(client, ignoreHTTPSErrors, this);\n        this._timeoutSettings = timeoutSettings;\n        this._client.on('Page.frameAttached', (event) => this._onFrameAttached(event.frameId, event.parentFrameId));\n        this._client.on('Page.frameNavigated', (event) => this._onFrameNavigated(event.frame));\n        this._client.on('Page.navigatedWithinDocument', (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));\n        this._client.on('Page.frameDetached', (event) => this._onFrameDetached(event.frameId));\n        this._client.on('Page.frameStoppedLoading', (event) => this._onFrameStoppedLoading(event.frameId));\n        this._client.on('Runtime.executionContextCreated', (event) => this._onExecutionContextCreated(event.context));\n        this._client.on('Runtime.executionContextDestroyed', (event) => this._onExecutionContextDestroyed(event.executionContextId));\n        this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());\n        this._client.on('Page.lifecycleEvent', (event) => this._onLifecycleEvent(event));\n        this._client.on('Target.attachedToTarget', async (event) => this._onFrameMoved(event));\n    }\n    async initialize() {\n        const result = await Promise.all([\n            this._client.send('Page.enable'),\n            this._client.send('Page.getFrameTree'),\n        ]);\n        const { frameTree } = result[1];\n        this._handleFrameTree(frameTree);\n        await Promise.all([\n            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),\n            this._client\n                .send('Runtime.enable')\n                .then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),\n            this._networkManager.initialize(),\n        ]);\n    }\n    networkManager() {\n        return this._networkManager;\n    }\n    async navigateFrame(frame, url, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { referer = this._networkManager.extraHTTPHeaders()['referer'], waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);\n        let ensureNewDocumentNavigation = false;\n        let error = await Promise.race([\n            navigate(this._client, url, referer, frame._id),\n            watcher.timeoutOrTerminationPromise(),\n        ]);\n        if (!error) {\n            error = await Promise.race([\n                watcher.timeoutOrTerminationPromise(),\n                ensureNewDocumentNavigation\n                    ? watcher.newDocumentNavigationPromise()\n                    : watcher.sameDocumentNavigationPromise(),\n            ]);\n        }\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n        async function navigate(client, url, referrer, frameId) {\n            try {\n                const response = await client.send('Page.navigate', {\n                    url,\n                    referrer,\n                    frameId,\n                });\n                ensureNewDocumentNavigation = !!response.loaderId;\n                return response.errorText\n                    ? new Error(`${response.errorText} at ${url}`)\n                    : null;\n            }\n            catch (error) {\n                return error;\n            }\n        }\n    }\n    async waitForFrameNavigation(frame, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);\n        const error = await Promise.race([\n            watcher.timeoutOrTerminationPromise(),\n            watcher.sameDocumentNavigationPromise(),\n            watcher.newDocumentNavigationPromise(),\n        ]);\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n    }\n    async _onFrameMoved(event) {\n        if (event.targetInfo.type !== 'iframe') {\n            return;\n        }\n        // TODO(sadym): Remove debug message once proper OOPIF support is\n        // implemented: https://github.com/puppeteer/puppeteer/issues/2548\n        debug('puppeteer:frame')(`The frame '${event.targetInfo.targetId}' moved to another session. ` +\n            `Out-of-process iframes (OOPIF) are not supported by Puppeteer yet. ` +\n            `https://github.com/puppeteer/puppeteer/issues/2548`);\n    }\n    _onLifecycleEvent(event) {\n        const frame = this._frames.get(event.frameId);\n        if (!frame)\n            return;\n        frame._onLifecycleEvent(event.loaderId, event.name);\n        this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _onFrameStoppedLoading(frameId) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._onLoadingStopped();\n        this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _handleFrameTree(frameTree) {\n        if (frameTree.frame.parentId)\n            this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);\n        this._onFrameNavigated(frameTree.frame);\n        if (!frameTree.childFrames)\n            return;\n        for (const child of frameTree.childFrames)\n            this._handleFrameTree(child);\n    }\n    page() {\n        return this._page;\n    }\n    mainFrame() {\n        return this._mainFrame;\n    }\n    frames() {\n        return Array.from(this._frames.values());\n    }\n    frame(frameId) {\n        return this._frames.get(frameId) || null;\n    }\n    _onFrameAttached(frameId, parentFrameId) {\n        if (this._frames.has(frameId))\n            return;\n        assert(parentFrameId);\n        const parentFrame = this._frames.get(parentFrameId);\n        const frame = new Frame(this, parentFrame, frameId);\n        this._frames.set(frame._id, frame);\n        this.emit(FrameManagerEmittedEvents.FrameAttached, frame);\n    }\n    _onFrameNavigated(framePayload) {\n        const isMainFrame = !framePayload.parentId;\n        let frame = isMainFrame\n            ? this._mainFrame\n            : this._frames.get(framePayload.id);\n        assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');\n        // Detach all child frames first.\n        if (frame) {\n            for (const child of frame.childFrames())\n                this._removeFramesRecursively(child);\n        }\n        // Update or create main frame.\n        if (isMainFrame) {\n            if (frame) {\n                // Update frame id to retain frame identity on cross-process navigation.\n                this._frames.delete(frame._id);\n                frame._id = framePayload.id;\n            }\n            else {\n                // Initial main frame navigation.\n                frame = new Frame(this, null, framePayload.id);\n            }\n            this._frames.set(framePayload.id, frame);\n            this._mainFrame = frame;\n        }\n        // Update frame payload.\n        frame._navigated(framePayload);\n        this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    async _ensureIsolatedWorld(name) {\n        if (this._isolatedWorlds.has(name))\n            return;\n        this._isolatedWorlds.add(name);\n        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n            source: `//# sourceURL=${EVALUATION_SCRIPT_URL}`,\n            worldName: name,\n        });\n        // Frames might be removed before we send this.\n        await Promise.all(this.frames().map((frame) => this._client\n            .send('Page.createIsolatedWorld', {\n            frameId: frame._id,\n            worldName: name,\n            grantUniveralAccess: true,\n        })\n            .catch(debugError)));\n    }\n    _onFrameNavigatedWithinDocument(frameId, url) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._navigatedWithinDocument(url);\n        this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n        this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    _onFrameDetached(frameId) {\n        const frame = this._frames.get(frameId);\n        if (frame)\n            this._removeFramesRecursively(frame);\n    }\n    _onExecutionContextCreated(contextPayload) {\n        const auxData = contextPayload.auxData;\n        const frameId = auxData ? auxData.frameId : null;\n        const frame = this._frames.get(frameId) || null;\n        let world = null;\n        if (frame) {\n            if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n                world = frame._mainWorld;\n            }\n            else if (contextPayload.name === UTILITY_WORLD_NAME &&\n                !frame._secondaryWorld._hasContext()) {\n                // In case of multiple sessions to the same target, there's a race between\n                // connections so we might end up creating multiple isolated worlds.\n                // We can use either.\n                world = frame._secondaryWorld;\n            }\n        }\n        const context = new ExecutionContext(this._client, contextPayload, world);\n        if (world)\n            world._setContext(context);\n        this._contextIdToContext.set(contextPayload.id, context);\n    }\n    _onExecutionContextDestroyed(executionContextId) {\n        const context = this._contextIdToContext.get(executionContextId);\n        if (!context)\n            return;\n        this._contextIdToContext.delete(executionContextId);\n        if (context._world)\n            context._world._setContext(null);\n    }\n    _onExecutionContextsCleared() {\n        for (const context of this._contextIdToContext.values()) {\n            if (context._world)\n                context._world._setContext(null);\n        }\n        this._contextIdToContext.clear();\n    }\n    executionContextById(contextId) {\n        const context = this._contextIdToContext.get(contextId);\n        assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n        return context;\n    }\n    _removeFramesRecursively(frame) {\n        for (const child of frame.childFrames())\n            this._removeFramesRecursively(child);\n        frame._detach();\n        this._frames.delete(frame._id);\n        this.emit(FrameManagerEmittedEvents.FrameDetached, frame);\n    }\n}\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\nexport class Frame {\n    /**\n     * @internal\n     */\n    constructor(frameManager, parentFrame, frameId) {\n        this._url = '';\n        this._detached = false;\n        /**\n         * @internal\n         */\n        this._loaderId = '';\n        /**\n         * @internal\n         */\n        this._lifecycleEvents = new Set();\n        this._frameManager = frameManager;\n        this._parentFrame = parentFrame;\n        this._url = '';\n        this._id = frameId;\n        this._detached = false;\n        this._loaderId = '';\n        this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);\n        this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);\n        this._childFrames = new Set();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.add(this);\n    }\n    /**\n     * @remarks\n     *\n     * `frame.goto` will throw an error if:\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     *\n     * - target URL is invalid.\n     *\n     * - the `timeout` is exceeded during navigation.\n     *\n     * - the remote server does not respond or is unreachable.\n     *\n     * - the main resource failed to load.\n     *\n     * `frame.goto` will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\".  The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     *\n     * NOTE: `frame.goto` either throws an error or returns a main resource\n     * response. The only exceptions are navigation to `about:blank` or\n     * navigation to the same URL with a different hash, which would succeed and\n     * return `null`.\n     *\n     * NOTE: Headless mode doesn't support navigation to a PDF document. See\n     * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * @param url - the URL to navigate the frame to. This should include the\n     * scheme, e.g. `https://`.\n     * @param options - navigation options. `waitUntil` is useful to define when\n     * the navigation should be considered successful - see the docs for\n     * {@link PuppeteerLifeCycleEvent} for more details.\n     *\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     */\n    async goto(url, options = {}) {\n        return await this._frameManager.navigateFrame(this, url, options);\n    }\n    /**\n     * @remarks\n     *\n     * This resolves when the frame navigates to a new URL. It is useful for when\n     * you run code which will indirectly cause the frame to navigate. Consider\n     * this example:\n     *\n     * ```js\n     * const [response] = await Promise.all([\n     *   // The navigation promise resolves after navigation has finished\n     *   frame.waitForNavigation(),\n     *   // Clicking the link will indirectly cause a navigation\n     *   frame.click('a.my-link'),\n     * ]);\n     * ```\n     *\n     * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n     *\n     * @param options - options to configure when the navigation is consided finished.\n     * @returns a promise that resolves when the frame navigates to a new URL.\n     */\n    async waitForNavigation(options = {}) {\n        return await this._frameManager.waitForFrameNavigation(this, options);\n    }\n    /**\n     * @returns a promise that resolves to the frame's default execution context.\n     */\n    executionContext() {\n        return this._mainWorld.executionContext();\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Frame.evaluate} and\n     * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * This method behaves identically to {@link Page.evaluateHandle} except it's\n     * run within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return this._mainWorld.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves identically to {@link Page.evaluate} except it's run\n     * within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluate(pageFunction, ...args) {\n        return this._mainWorld.evaluate(pageFunction, ...args);\n    }\n    /**\n     * This method queries the frame for the given selector.\n     *\n     * @param selector - a selector to query for.\n     * @returns A promise which resolves to an `ElementHandle` pointing at the\n     * element, or `null` if it was not found.\n     */\n    async $(selector) {\n        return this._mainWorld.$(selector);\n    }\n    /**\n     * This method evaluates the given XPath expression and returns the results.\n     *\n     * @param expression - the XPath expression to evaluate.\n     */\n    async $x(expression) {\n        return this._mainWorld.$x(expression);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `document.querySelector` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const searchValue = await frame.$eval('#search', el => el.value);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const divsCounts = await frame.$$eval('div', divs => divs.length);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $$eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This runs `document.querySelectorAll` in the frame and returns the result.\n     *\n     * @param selector - a selector to search for\n     * @returns An array of element handles pointing to the found frame elements.\n     */\n    async $$(selector) {\n        return this._mainWorld.$$(selector);\n    }\n    /**\n     * @returns the full HTML contents of the frame, including the doctype.\n     */\n    async content() {\n        return this._secondaryWorld.content();\n    }\n    /**\n     * Set the content of the frame.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - options to configure how long before timing out and at\n     * what point to consider the content setting successful.\n     */\n    async setContent(html, options = {}) {\n        return this._secondaryWorld.setContent(html, options);\n    }\n    /**\n     * @remarks\n     *\n     * If the name is empty, it returns the `id` attribute instead.\n     *\n     * Note: This value is calculated once when the frame is created, and will not\n     * update if the attribute is changed later.\n     *\n     * @returns the frame's `name` attribute as specified in the tag.\n     */\n    name() {\n        return this._name || '';\n    }\n    /**\n     * @returns the frame's URL.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n     */\n    parentFrame() {\n        return this._parentFrame;\n    }\n    /**\n     * @returns an array of child frames.\n     */\n    childFrames() {\n        return Array.from(this._childFrames);\n    }\n    /**\n     * @returns `true` if the frame has been detached, or `false` otherwise.\n     */\n    isDetached() {\n        return this._detached;\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired url or content.\n     *\n     * @param options - configure the script to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the script's\n     * `onload` event fires or when the script content was injected into the\n     * frame.\n     */\n    async addScriptTag(options) {\n        return this._mainWorld.addScriptTag(options);\n    }\n    /**\n     * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n     * a `<style type=\"text/css\">` tag with the content.\n     *\n     * @param options - configure the CSS to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the stylesheets's\n     * `onload` event fires or when the CSS content was injected into the\n     * frame.\n     */\n    async addStyleTag(options) {\n        return this._mainWorld.addStyleTag(options);\n    }\n    /**\n     *\n     * This method clicks the first element found that matches `selector`.\n     *\n     * @remarks\n     *\n     * This method scrolls the element into view if needed, and then uses\n     * {@link Page.mouse} to click in the center of the element. If there's no\n     * element matching `selector`, the method throws an error.\n     *\n     * Bear in mind that if `click()` triggers a navigation event and there's a\n     * separate `page.waitForNavigation()` promise to be resolved, you may end up\n     * with a race condition that yields unexpected results. The correct pattern\n     * for click and wait for navigation is the following:\n     *\n     * ```javascript\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   frame.click(selector, clickOptions),\n     * ]);\n     * ```\n     * @param selector - the selector to search for to click. If there are\n     * multiple elements, the first will be clicked.\n     */\n    async click(selector, options = {}) {\n        return this._secondaryWorld.click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector for the element to focus. If there are\n     * multiple elements, the first will be focused.\n     */\n    async focus(selector) {\n        return this._secondaryWorld.focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse} to hover over the center of the\n     * element.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an\n     *\n     * @param selector - the selector for the element to hover. If there are\n     * multiple elements, the first will be hovered.\n     */\n    async hover(selector) {\n        return this._secondaryWorld.hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have\n     * been selected.\n     *\n     * @remarks\n     *\n     * If there's no `<select>` element matching `selector`, the\n     * method throws an error.\n     *\n     * @example\n     * ```js\n     * frame.select('select#colors', 'blue'); // single selection\n     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - a selector to query the frame for\n     * @param values - an array of values to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     * @returns the list of values that were successfully selected.\n     */\n    select(selector, ...values) {\n        return this._secondaryWorld.select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n     * element.\n     *\n     * @remarks\n     *\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector to tap.\n     * @returns a promise that resolves when the element has been tapped.\n     */\n    async tap(selector) {\n        return this._secondaryWorld.tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n     * in the text.\n     *\n     * @remarks\n     * To press a special key, like `Control` or `ArrowDown`, use\n     * {@link Keyboard.press}.\n     *\n     * @example\n     * ```js\n     * await frame.type('#mytextarea', 'Hello'); // Types instantly\n     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @param selector - the selector for the element to type into. If there are\n     * multiple the first will be used.\n     * @param text - text to type into the element\n     * @param options - takes one option, `delay`, which sets the time to wait\n     * between key presses in milliseconds. Defaults to `0`.\n     *\n     * @returns a promise that resolves when the typing is complete.\n     */\n    async type(selector, text, options) {\n        return this._mainWorld.type(selector, text, options);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves differently depending on the first parameter. If it's a\n     * `string`, it will be treated as a `selector` or `xpath` (if the string\n     * starts with `//`). This method then is a shortcut for\n     * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n     *\n     * If the first argument is a function this method is a shortcut for\n     * {@link Frame.waitForFunction}.\n     *\n     * If the first argument is a `number`, it's treated as a timeout in\n     * milliseconds and the method returns a promise which resolves after the\n     * timeout.\n     *\n     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n     * wait for.\n     * @param options - optional waiting parameters.\n     * @param args - arguments to pass to `pageFunction`.\n     *\n     * @deprecated Don't use this method directly. Instead use the more explicit\n     * methods available: {@link Frame.waitForSelector},\n     * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n     * {@link Frame.waitForTimeout}.\n     */\n    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n        const xPathPattern = '//';\n        console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n        if (helper.isString(selectorOrFunctionOrTimeout)) {\n            const string = selectorOrFunctionOrTimeout;\n            if (string.startsWith(xPathPattern))\n                return this.waitForXPath(string, options);\n            return this.waitForSelector(string, options);\n        }\n        if (helper.isNumber(selectorOrFunctionOrTimeout))\n            return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n        if (typeof selectorOrFunctionOrTimeout === 'function')\n            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n        return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n    }\n    /**\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```\n     * await frame.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    waitForTimeout(milliseconds) {\n        return new Promise((resolve) => {\n            setTimeout(resolve, milliseconds);\n        });\n    }\n    /**\n     * @remarks\n     *\n     *\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately.\n     * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n     * the function will throw.\n     *\n     * This method works across navigations.\n     *\n     * @example\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page.mainFrame()\n     *   .waitForSelector('img')\n     *   .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     * @param selector - the selector to wait for.\n     * @param options - options to define if the element should be visible and how\n     * long to wait before timing out.\n     * @returns a promise which resolves when an element matching the selector\n     * string is added to the DOM.\n     */\n    async waitForSelector(selector, options = {}) {\n        const handle = await this._secondaryWorld.waitForSelector(selector, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     * Wait for the `xpath` to appear in page. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * For a code example, see the example for {@link Frame.waitForSelector}. That\n     * function behaves identically other than taking a CSS selector rather than\n     * an XPath.\n     *\n     * @param xpath - the XPath expression to wait for.\n     * @param options  - options to configure the visiblity of the element and how\n     * long to wait before timing out.\n     */\n    async waitForXPath(xpath, options = {}) {\n        const handle = await this._secondaryWorld.waitForXPath(xpath, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     *\n     * @example\n     *\n     * The `waitForFunction` can be used to observe viewport size change:\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     * .  const browser = await puppeteer.launch();\n     * .  const page = await browser.newPage();\n     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n     * .  page.setViewport({width: 50, height: 50});\n     * .  await watchDog;\n     * .  await browser.close();\n     * })();\n     * ```\n     *\n     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n     *\n     * ```js\n     * const selector = '.foo';\n     * await frame.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {}, // empty options object\n     *   selector\n     *);\n     * ```\n     *\n     * @param pageFunction - the function to evaluate in the frame context.\n     * @param options - options to configure the polling method and timeout.\n     * @param args - arguments to pass to the `pageFunction`.\n     * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n     */\n    waitForFunction(pageFunction, options = {}, ...args) {\n        return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n    }\n    /**\n     * @returns the frame's title.\n     */\n    async title() {\n        return this._secondaryWorld.title();\n    }\n    /**\n     * @internal\n     */\n    _navigated(framePayload) {\n        this._name = framePayload.name;\n        this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n    }\n    /**\n     * @internal\n     */\n    _navigatedWithinDocument(url) {\n        this._url = url;\n    }\n    /**\n     * @internal\n     */\n    _onLifecycleEvent(loaderId, name) {\n        if (name === 'init') {\n            this._loaderId = loaderId;\n            this._lifecycleEvents.clear();\n        }\n        this._lifecycleEvents.add(name);\n    }\n    /**\n     * @internal\n     */\n    _onLoadingStopped() {\n        this._lifecycleEvents.add('DOMContentLoaded');\n        this._lifecycleEvents.add('load');\n    }\n    /**\n     * @internal\n     */\n    _detach() {\n        this._detached = true;\n        this._mainWorld._detach();\n        this._secondaryWorld._detach();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.delete(this);\n        this._parentFrame = null;\n    }\n}\nfunction assertNoLegacyNavigationOptions(options) {\n    assert(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n    assert(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n    assert(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n}\n//# sourceMappingURL=FrameManager.js.map"]},"metadata":{},"sourceType":"module"}