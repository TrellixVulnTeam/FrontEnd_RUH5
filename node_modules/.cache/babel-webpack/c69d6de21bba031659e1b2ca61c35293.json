{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { LifecycleWatcher } from './LifecycleWatcher.js';\nimport { TimeoutError } from './Errors.js';\nimport { getQueryHandlerAndSelector } from './QueryHandler.js';\nimport { isNode } from '../environment.js';\n/**\n * @internal\n */\n\nexport class DOMWorld {\n  constructor(frameManager, frame, timeoutSettings) {\n    this._documentPromise = null;\n    this._contextPromise = null;\n    this._contextResolveCallback = null;\n    this._detached = false;\n    /**\n     * @internal\n     */\n\n    this._waitTasks = new Set();\n    /**\n     * @internal\n     * Contains mapping from functions that should be bound to Puppeteer functions.\n     */\n\n    this._boundFunctions = new Map(); // Set of bindings that have been registered in the current context.\n\n    this._ctxBindings = new Set(); // If multiple waitFor are set up asynchronously, we need to wait for the\n    // first one to set up the binding in the page before running the others.\n\n    this._settingUpBinding = null;\n    this._frameManager = frameManager;\n    this._frame = frame;\n    this._timeoutSettings = timeoutSettings;\n\n    this._setContext(null);\n\n    frameManager._client.on('Runtime.bindingCalled', event => this._onBindingCalled(event));\n  }\n\n  frame() {\n    return this._frame;\n  }\n\n  _setContext(context) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (context) {\n        _this._ctxBindings.clear();\n\n        _this._contextResolveCallback.call(null, context);\n\n        _this._contextResolveCallback = null;\n\n        for (const waitTask of _this._waitTasks) waitTask.rerun();\n      } else {\n        _this._documentPromise = null;\n        _this._contextPromise = new Promise(fulfill => {\n          _this._contextResolveCallback = fulfill;\n        });\n      }\n    })();\n  }\n\n  _hasContext() {\n    return !this._contextResolveCallback;\n  }\n\n  _detach() {\n    this._detached = true;\n\n    for (const waitTask of this._waitTasks) waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n  }\n\n  executionContext() {\n    if (this._detached) throw new Error(`Execution context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n    return this._contextPromise;\n  }\n\n  evaluateHandle(pageFunction, ...args) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const context = yield _this2.executionContext();\n      return context.evaluateHandle(pageFunction, ...args);\n    })();\n  }\n\n  evaluate(pageFunction, ...args) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const context = yield _this3.executionContext();\n      return context.evaluate(pageFunction, ...args);\n    })();\n  }\n\n  $(selector) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const document = yield _this4._document();\n      const value = yield document.$(selector);\n      return value;\n    })();\n  }\n\n  _document() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this5._documentPromise) return _this5._documentPromise;\n      _this5._documentPromise = _this5.executionContext().then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (context) {\n          const document = yield context.evaluateHandle('document');\n          return document.asElement();\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return _this5._documentPromise;\n    })();\n  }\n\n  $x(expression) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const document = yield _this6._document();\n      const value = yield document.$x(expression);\n      return value;\n    })();\n  }\n\n  $eval(selector, pageFunction, ...args) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const document = yield _this7._document();\n      return document.$eval(selector, pageFunction, ...args);\n    })();\n  }\n\n  $$eval(selector, pageFunction, ...args) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const document = yield _this8._document();\n      const value = yield document.$$eval(selector, pageFunction, ...args);\n      return value;\n    })();\n  }\n\n  $$(selector) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const document = yield _this9._document();\n      const value = yield document.$$(selector);\n      return value;\n    })();\n  }\n\n  content() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this10.evaluate(() => {\n        let retVal = '';\n        if (document.doctype) retVal = new XMLSerializer().serializeToString(document.doctype);\n        if (document.documentElement) retVal += document.documentElement.outerHTML;\n        return retVal;\n      });\n    })();\n  }\n\n  setContent(html, options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        waitUntil = ['load'],\n        timeout = _this11._timeoutSettings.navigationTimeout()\n      } = options; // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n      // lifecycle event. @see https://crrev.com/608658\n\n      yield _this11.evaluate(html => {\n        document.open();\n        document.write(html);\n        document.close();\n      }, html);\n      const watcher = new LifecycleWatcher(_this11._frameManager, _this11._frame, waitUntil, timeout);\n      const error = yield Promise.race([watcher.timeoutOrTerminationPromise(), watcher.lifecyclePromise()]);\n      watcher.dispose();\n      if (error) throw error;\n    })();\n  }\n  /**\n   * Adds a script tag into the current context.\n   *\n   * @remarks\n   *\n   * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n   * in a browser environment you cannot pass a filepath and should use either\n   * `url` or `content`.\n   */\n\n\n  addScriptTag(options) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        url = null,\n        path = null,\n        content = null,\n        type = ''\n      } = options;\n\n      if (url !== null) {\n        try {\n          const context = yield _this12.executionContext();\n          return (yield context.evaluateHandle(addScriptUrl, url, type)).asElement();\n        } catch (error) {\n          throw new Error(`Loading script from ${url} failed`);\n        }\n      }\n\n      if (path !== null) {\n        if (!isNode) {\n          throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');\n        }\n\n        const fs = yield helper.importFSModule();\n        let contents = yield fs.promises.readFile(path, 'utf8');\n        contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n        const context = yield _this12.executionContext();\n        return (yield context.evaluateHandle(addScriptContent, contents, type)).asElement();\n      }\n\n      if (content !== null) {\n        const context = yield _this12.executionContext();\n        return (yield context.evaluateHandle(addScriptContent, content, type)).asElement();\n      }\n\n      throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n      function addScriptUrl(_x2, _x3) {\n        return _addScriptUrl.apply(this, arguments);\n      }\n\n      function _addScriptUrl() {\n        _addScriptUrl = _asyncToGenerator(function* (url, type) {\n          const script = document.createElement('script');\n          script.src = url;\n          if (type) script.type = type;\n          const promise = new Promise((res, rej) => {\n            script.onload = res;\n            script.onerror = rej;\n          });\n          document.head.appendChild(script);\n          yield promise;\n          return script;\n        });\n        return _addScriptUrl.apply(this, arguments);\n      }\n\n      function addScriptContent(content, type = 'text/javascript') {\n        const script = document.createElement('script');\n        script.type = type;\n        script.text = content;\n        let error = null;\n\n        script.onerror = e => error = e;\n\n        document.head.appendChild(script);\n        if (error) throw error;\n        return script;\n      }\n    })();\n  }\n  /**\n   * Adds a style tag into the current context.\n   *\n   * @remarks\n   *\n   * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n   * in a browser environment you cannot pass a filepath and should use either\n   * `url` or `content`.\n   *\n   */\n\n\n  addStyleTag(options) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        url = null,\n        path = null,\n        content = null\n      } = options;\n\n      if (url !== null) {\n        try {\n          const context = yield _this13.executionContext();\n          return (yield context.evaluateHandle(addStyleUrl, url)).asElement();\n        } catch (error) {\n          throw new Error(`Loading style from ${url} failed`);\n        }\n      }\n\n      if (path !== null) {\n        if (!isNode) {\n          throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');\n        }\n\n        const fs = yield helper.importFSModule();\n        let contents = yield fs.promises.readFile(path, 'utf8');\n        contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n        const context = yield _this13.executionContext();\n        return (yield context.evaluateHandle(addStyleContent, contents)).asElement();\n      }\n\n      if (content !== null) {\n        const context = yield _this13.executionContext();\n        return (yield context.evaluateHandle(addStyleContent, content)).asElement();\n      }\n\n      throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n      function addStyleUrl(_x4) {\n        return _addStyleUrl.apply(this, arguments);\n      }\n\n      function _addStyleUrl() {\n        _addStyleUrl = _asyncToGenerator(function* (url) {\n          const link = document.createElement('link');\n          link.rel = 'stylesheet';\n          link.href = url;\n          const promise = new Promise((res, rej) => {\n            link.onload = res;\n            link.onerror = rej;\n          });\n          document.head.appendChild(link);\n          yield promise;\n          return link;\n        });\n        return _addStyleUrl.apply(this, arguments);\n      }\n\n      function addStyleContent(_x5) {\n        return _addStyleContent.apply(this, arguments);\n      }\n\n      function _addStyleContent() {\n        _addStyleContent = _asyncToGenerator(function* (content) {\n          const style = document.createElement('style');\n          style.type = 'text/css';\n          style.appendChild(document.createTextNode(content));\n          const promise = new Promise((res, rej) => {\n            style.onload = res;\n            style.onerror = rej;\n          });\n          document.head.appendChild(style);\n          yield promise;\n          return style;\n        });\n        return _addStyleContent.apply(this, arguments);\n      }\n    })();\n  }\n\n  click(selector, options) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this14.$(selector);\n      assert(handle, 'No node found for selector: ' + selector);\n      yield handle.click(options);\n      yield handle.dispose();\n    })();\n  }\n\n  focus(selector) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this15.$(selector);\n      assert(handle, 'No node found for selector: ' + selector);\n      yield handle.focus();\n      yield handle.dispose();\n    })();\n  }\n\n  hover(selector) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this16.$(selector);\n      assert(handle, 'No node found for selector: ' + selector);\n      yield handle.hover();\n      yield handle.dispose();\n    })();\n  }\n\n  select(selector, ...values) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this17.$(selector);\n      assert(handle, 'No node found for selector: ' + selector);\n      const result = yield handle.select(...values);\n      yield handle.dispose();\n      return result;\n    })();\n  }\n\n  tap(selector) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this18.$(selector);\n      yield handle.tap();\n      yield handle.dispose();\n    })();\n  }\n\n  type(selector, text, options) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      const handle = yield _this19.$(selector);\n      assert(handle, 'No node found for selector: ' + selector);\n      yield handle.type(text, options);\n      yield handle.dispose();\n    })();\n  }\n\n  waitForSelector(selector, options) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        updatedSelector,\n        queryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return queryHandler.waitFor(_this20, updatedSelector, options);\n    })();\n  }\n  /**\n   * @internal\n   */\n\n\n  addBindingToContext(context, name) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      // Previous operation added the binding so we are done.\n      if (_this21._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {\n        return;\n      } // Wait for other operation to finish\n\n\n      if (_this21._settingUpBinding) {\n        yield _this21._settingUpBinding;\n        return _this21.addBindingToContext(context, name);\n      }\n\n      const bind = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (name) {\n          const expression = helper.pageBindingInitString('internal', name);\n\n          try {\n            // TODO: In theory, it would be enough to call this just once\n            yield context._client.send('Runtime.addBinding', {\n              name,\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore The protocol definition is not up to date.\n              executionContextName: context._contextName\n            });\n            yield context.evaluate(expression);\n          } catch (error) {\n            // We could have tried to evaluate in a context which was already\n            // destroyed. This happens, for example, if the page is navigated while\n            // we are trying to add the binding\n            const ctxDestroyed = error.message.includes('Execution context was destroyed');\n            const ctxNotFound = error.message.includes('Cannot find context with specified id');\n\n            if (ctxDestroyed || ctxNotFound) {\n              return;\n            } else {\n              debugError(error);\n              return;\n            }\n          }\n\n          _this21._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));\n        });\n\n        return function bind(_x6) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      _this21._settingUpBinding = bind(name);\n      yield _this21._settingUpBinding;\n      _this21._settingUpBinding = null;\n    })();\n  }\n\n  _onBindingCalled(event) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      let payload;\n      if (!_this22._hasContext()) return;\n      const context = yield _this22.executionContext();\n\n      try {\n        payload = JSON.parse(event.payload);\n      } catch {\n        // The binding was either called by something in the page or it was\n        // called before our wrapper was initialized.\n        return;\n      }\n\n      const {\n        type,\n        name,\n        seq,\n        args\n      } = payload;\n      if (type !== 'internal' || !_this22._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) return;\n      if (context._contextId !== event.executionContextId) return;\n\n      try {\n        const result = yield _this22._boundFunctions.get(name)(...args);\n        yield context.evaluate(deliverResult, name, seq, result);\n      } catch (error) {\n        // The WaitTask may already have been resolved by timing out, or the\n        // exection context may have been destroyed.\n        // In both caes, the promises above are rejected with a protocol error.\n        // We can safely ignores these, as the WaitTask is re-installed in\n        // the next execution context if needed.\n        if (error.message.includes('Protocol error')) return;\n        debugError(error);\n      }\n\n      function deliverResult(name, seq, result) {\n        globalThis[name].callbacks.get(seq).resolve(result);\n        globalThis[name].callbacks.delete(seq);\n      }\n    })();\n  }\n  /**\n   * @internal\n   */\n\n\n  waitForSelectorInPage(queryOne, selector, options, binding) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        visible: waitForVisible = false,\n        hidden: waitForHidden = false,\n        timeout = _this23._timeoutSettings.timeout()\n      } = options;\n      const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n      const title = `selector \\`${selector}\\`${waitForHidden ? ' to be hidden' : ''}`;\n\n      function predicate(_x7, _x8, _x9) {\n        return _predicate.apply(this, arguments);\n      }\n\n      function _predicate() {\n        _predicate = _asyncToGenerator(function* (selector, waitForVisible, waitForHidden) {\n          const node = predicateQueryHandler ? yield predicateQueryHandler(document, selector) : document.querySelector(selector);\n          return checkWaitForOptions(node, waitForVisible, waitForHidden);\n        });\n        return _predicate.apply(this, arguments);\n      }\n\n      const waitTaskOptions = {\n        domWorld: _this23,\n        predicateBody: helper.makePredicateString(predicate, queryOne),\n        title,\n        polling,\n        timeout,\n        args: [selector, waitForVisible, waitForHidden],\n        binding\n      };\n      const waitTask = new WaitTask(waitTaskOptions);\n      const jsHandle = yield waitTask.promise;\n      const elementHandle = jsHandle.asElement();\n\n      if (!elementHandle) {\n        yield jsHandle.dispose();\n        return null;\n      }\n\n      return elementHandle;\n    })();\n  }\n\n  waitForXPath(xpath, options) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        visible: waitForVisible = false,\n        hidden: waitForHidden = false,\n        timeout = _this24._timeoutSettings.timeout()\n      } = options;\n      const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n      const title = `XPath \\`${xpath}\\`${waitForHidden ? ' to be hidden' : ''}`;\n\n      function predicate(xpath, waitForVisible, waitForHidden) {\n        const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n        return checkWaitForOptions(node, waitForVisible, waitForHidden);\n      }\n\n      const waitTaskOptions = {\n        domWorld: _this24,\n        predicateBody: helper.makePredicateString(predicate),\n        title,\n        polling,\n        timeout,\n        args: [xpath, waitForVisible, waitForHidden]\n      };\n      const waitTask = new WaitTask(waitTaskOptions);\n      const jsHandle = yield waitTask.promise;\n      const elementHandle = jsHandle.asElement();\n\n      if (!elementHandle) {\n        yield jsHandle.dispose();\n        return null;\n      }\n\n      return elementHandle;\n    })();\n  }\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const waitTaskOptions = {\n      domWorld: this,\n      predicateBody: pageFunction,\n      title: 'function',\n      polling,\n      timeout,\n      args\n    };\n    const waitTask = new WaitTask(waitTaskOptions);\n    return waitTask.promise;\n  }\n\n  title() {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this25.evaluate(() => document.title);\n    })();\n  }\n\n}\n\nDOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;\n/**\n * @internal\n */\n\n\nexport class WaitTask {\n  constructor(options) {\n    this._runCount = 0;\n    this._terminated = false;\n    if (helper.isString(options.polling)) assert(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);else if (helper.isNumber(options.polling)) assert(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);else throw new Error('Unknown polling options: ' + options.polling);\n\n    function getPredicateBody(predicateBody) {\n      if (helper.isString(predicateBody)) return `return (${predicateBody});`;\n      return `return (${predicateBody})(...args);`;\n    }\n\n    this._domWorld = options.domWorld;\n    this._polling = options.polling;\n    this._timeout = options.timeout;\n    this._predicateBody = getPredicateBody(options.predicateBody);\n    this._args = options.args;\n    this._binding = options.binding;\n    this._runCount = 0;\n\n    this._domWorld._waitTasks.add(this);\n\n    if (this._binding) {\n      this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);\n    }\n\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    }); // Since page navigation requires us to re-install the pageScript, we should track\n    // timeout on our end.\n\n    if (options.timeout) {\n      const timeoutError = new TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);\n      this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);\n    }\n\n    this.rerun();\n  }\n\n  terminate(error) {\n    this._terminated = true;\n\n    this._reject(error);\n\n    this._cleanup();\n  }\n\n  rerun() {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      const runCount = ++_this26._runCount;\n      let success = null;\n      let error = null;\n      const context = yield _this26._domWorld.executionContext();\n      if (_this26._terminated || runCount !== _this26._runCount) return;\n\n      if (_this26._binding) {\n        yield _this26._domWorld.addBindingToContext(context, _this26._binding.name);\n      }\n\n      if (_this26._terminated || runCount !== _this26._runCount) return;\n\n      try {\n        success = yield context.evaluateHandle(waitForPredicatePageFunction, _this26._predicateBody, _this26._polling, _this26._timeout, ..._this26._args);\n      } catch (error_) {\n        error = error_;\n      }\n\n      if (_this26._terminated || runCount !== _this26._runCount) {\n        if (success) yield success.dispose();\n        return;\n      } // Ignore timeouts in pageScript - we track timeouts ourselves.\n      // If the frame's execution context has already changed, `frame.evaluate` will\n      // throw an error - ignore this predicate run altogether.\n\n\n      if (!error && (yield _this26._domWorld.evaluate(s => !s, success).catch(() => true))) {\n        yield success.dispose();\n        return;\n      }\n\n      if (error) {\n        if (error.message.includes('TypeError: binding is not a function')) {\n          return _this26.rerun();\n        } // When frame is detached the task should have been terminated by the DOMWorld.\n        // This can fail if we were adding this task while the frame was detached,\n        // so we terminate here instead.\n\n\n        if (error.message.includes('Execution context is not available in detached frame')) {\n          _this26.terminate(new Error('waitForFunction failed: frame got detached.'));\n\n          return;\n        } // When the page is navigated, the promise is rejected.\n        // We will try again in the new execution context.\n\n\n        if (error.message.includes('Execution context was destroyed')) return; // We could have tried to evaluate in a context which was already\n        // destroyed.\n\n        if (error.message.includes('Cannot find context with specified id')) return;\n\n        _this26._reject(error);\n      } else {\n        _this26._resolve(success);\n      }\n\n      _this26._cleanup();\n    })();\n  }\n\n  _cleanup() {\n    clearTimeout(this._timeoutTimer);\n\n    this._domWorld._waitTasks.delete(this);\n  }\n\n}\n\nfunction waitForPredicatePageFunction(_x10, _x11, _x12) {\n  return _waitForPredicatePageFunction.apply(this, arguments);\n} //# sourceMappingURL=DOMWorld.js.map\n\n\nfunction _waitForPredicatePageFunction() {\n  _waitForPredicatePageFunction = _asyncToGenerator(function* (predicateBody, polling, timeout, ...args) {\n    const predicate = new Function('...args', predicateBody);\n    let timedOut = false;\n    if (timeout) setTimeout(() => timedOut = true, timeout);\n    if (polling === 'raf') return yield pollRaf();\n    if (polling === 'mutation') return yield pollMutation();\n    if (typeof polling === 'number') return yield pollInterval(polling);\n    /**\n     * @returns {!Promise<*>}\n     */\n\n    function pollMutation() {\n      return _pollMutation.apply(this, arguments);\n    }\n\n    function _pollMutation() {\n      _pollMutation = _asyncToGenerator(function* () {\n        const success = yield predicate(...args);\n        if (success) return Promise.resolve(success);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const observer = new MutationObserver( /*#__PURE__*/_asyncToGenerator(function* () {\n          if (timedOut) {\n            observer.disconnect();\n            fulfill();\n          }\n\n          const success = yield predicate(...args);\n\n          if (success) {\n            observer.disconnect();\n            fulfill(success);\n          }\n        }));\n        observer.observe(document, {\n          childList: true,\n          subtree: true,\n          attributes: true\n        });\n        return result;\n      });\n      return _pollMutation.apply(this, arguments);\n    }\n\n    function pollRaf() {\n      return _pollRaf.apply(this, arguments);\n    }\n\n    function _pollRaf() {\n      _pollRaf = _asyncToGenerator(function* () {\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        yield onRaf();\n        return result;\n\n        function onRaf() {\n          return _onRaf.apply(this, arguments);\n        }\n\n        function _onRaf() {\n          _onRaf = _asyncToGenerator(function* () {\n            if (timedOut) {\n              fulfill();\n              return;\n            }\n\n            const success = yield predicate(...args);\n            if (success) fulfill(success);else requestAnimationFrame(onRaf);\n          });\n          return _onRaf.apply(this, arguments);\n        }\n      });\n      return _pollRaf.apply(this, arguments);\n    }\n\n    function pollInterval(_x13) {\n      return _pollInterval.apply(this, arguments);\n    }\n\n    function _pollInterval() {\n      _pollInterval = _asyncToGenerator(function* (pollInterval) {\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        yield onTimeout();\n        return result;\n\n        function onTimeout() {\n          return _onTimeout.apply(this, arguments);\n        }\n\n        function _onTimeout() {\n          _onTimeout = _asyncToGenerator(function* () {\n            if (timedOut) {\n              fulfill();\n              return;\n            }\n\n            const success = yield predicate(...args);\n            if (success) fulfill(success);else setTimeout(onTimeout, pollInterval);\n          });\n          return _onTimeout.apply(this, arguments);\n        }\n      });\n      return _pollInterval.apply(this, arguments);\n    }\n  });\n  return _waitForPredicatePageFunction.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/common/DOMWorld.js"],"names":["assert","helper","debugError","LifecycleWatcher","TimeoutError","getQueryHandlerAndSelector","isNode","DOMWorld","constructor","frameManager","frame","timeoutSettings","_documentPromise","_contextPromise","_contextResolveCallback","_detached","_waitTasks","Set","_boundFunctions","Map","_ctxBindings","_settingUpBinding","_frameManager","_frame","_timeoutSettings","_setContext","_client","on","event","_onBindingCalled","context","clear","call","waitTask","rerun","Promise","fulfill","_hasContext","_detach","terminate","Error","executionContext","url","evaluateHandle","pageFunction","args","evaluate","$","selector","document","_document","value","then","asElement","$x","expression","$eval","$$eval","$$","content","retVal","doctype","XMLSerializer","serializeToString","documentElement","outerHTML","setContent","html","options","waitUntil","timeout","navigationTimeout","open","write","close","watcher","error","race","timeoutOrTerminationPromise","lifecyclePromise","dispose","addScriptTag","path","type","addScriptUrl","fs","importFSModule","contents","promises","readFile","replace","addScriptContent","script","createElement","src","promise","res","rej","onload","onerror","head","appendChild","text","e","addStyleTag","addStyleUrl","addStyleContent","link","rel","href","style","createTextNode","click","handle","focus","hover","select","values","result","tap","waitForSelector","updatedSelector","queryHandler","waitFor","addBindingToContext","name","has","bindingIdentifier","_contextId","bind","pageBindingInitString","send","executionContextName","_contextName","ctxDestroyed","message","includes","ctxNotFound","add","payload","JSON","parse","seq","executionContextId","get","deliverResult","globalThis","callbacks","resolve","delete","waitForSelectorInPage","queryOne","binding","visible","waitForVisible","hidden","waitForHidden","polling","title","predicate","node","predicateQueryHandler","querySelector","checkWaitForOptions","waitTaskOptions","domWorld","predicateBody","makePredicateString","WaitTask","jsHandle","elementHandle","waitForXPath","xpath","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","waitForFunction","contextId","_runCount","_terminated","isString","isNumber","getPredicateBody","_domWorld","_polling","_timeout","_predicateBody","_args","_binding","set","pptrFunction","reject","_resolve","_reject","timeoutError","_timeoutTimer","setTimeout","_cleanup","runCount","success","waitForPredicatePageFunction","error_","s","catch","clearTimeout","Function","timedOut","pollRaf","pollMutation","pollInterval","x","observer","MutationObserver","disconnect","observe","childList","subtree","attributes","onRaf","requestAnimationFrame","onTimeout"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,aAAvB;AACA,SAASC,MAAT,EAAiBC,UAAjB,QAAmC,aAAnC;AACA,SAASC,gBAAT,QAAkC,uBAAlC;AACA,SAASC,YAAT,QAA6B,aAA7B;AACA,SAASC,0BAAT,QAA2C,mBAA3C;AACA,SAASC,MAAT,QAAuB,mBAAvB;AACA;AACA;AACA;;AACA,OAAO,MAAMC,QAAN,CAAe;AAClBC,EAAAA,WAAW,CAACC,YAAD,EAAeC,KAAf,EAAsBC,eAAtB,EAAuC;AAC9C,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,uBAAL,GAA+B,IAA/B;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA;AACR;AACA;;AACQ,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,IAAIC,GAAJ,EAAvB,CAb8C,CAc9C;;AACA,SAAKC,YAAL,GAAoB,IAAIH,GAAJ,EAApB,CAf8C,CAgB9C;AACA;;AACA,SAAKI,iBAAL,GAAyB,IAAzB;AACA,SAAKC,aAAL,GAAqBb,YAArB;AACA,SAAKc,MAAL,GAAcb,KAAd;AACA,SAAKc,gBAAL,GAAwBb,eAAxB;;AACA,SAAKc,WAAL,CAAiB,IAAjB;;AACAhB,IAAAA,YAAY,CAACiB,OAAb,CAAqBC,EAArB,CAAwB,uBAAxB,EAAkDC,KAAD,IAAW,KAAKC,gBAAL,CAAsBD,KAAtB,CAA5D;AACH;;AACDlB,EAAAA,KAAK,GAAG;AACJ,WAAO,KAAKa,MAAZ;AACH;;AACKE,EAAAA,WAAW,CAACK,OAAD,EAAU;AAAA;;AAAA;AACvB,UAAIA,OAAJ,EAAa;AACT,QAAA,KAAI,CAACV,YAAL,CAAkBW,KAAlB;;AACA,QAAA,KAAI,CAACjB,uBAAL,CAA6BkB,IAA7B,CAAkC,IAAlC,EAAwCF,OAAxC;;AACA,QAAA,KAAI,CAAChB,uBAAL,GAA+B,IAA/B;;AACA,aAAK,MAAMmB,QAAX,IAAuB,KAAI,CAACjB,UAA5B,EACIiB,QAAQ,CAACC,KAAT;AACP,OAND,MAOK;AACD,QAAA,KAAI,CAACtB,gBAAL,GAAwB,IAAxB;AACA,QAAA,KAAI,CAACC,eAAL,GAAuB,IAAIsB,OAAJ,CAAaC,OAAD,IAAa;AAC5C,UAAA,KAAI,CAACtB,uBAAL,GAA+BsB,OAA/B;AACH,SAFsB,CAAvB;AAGH;AAbsB;AAc1B;;AACDC,EAAAA,WAAW,GAAG;AACV,WAAO,CAAC,KAAKvB,uBAAb;AACH;;AACDwB,EAAAA,OAAO,GAAG;AACN,SAAKvB,SAAL,GAAiB,IAAjB;;AACA,SAAK,MAAMkB,QAAX,IAAuB,KAAKjB,UAA5B,EACIiB,QAAQ,CAACM,SAAT,CAAmB,IAAIC,KAAJ,CAAU,6CAAV,CAAnB;AACP;;AACDC,EAAAA,gBAAgB,GAAG;AACf,QAAI,KAAK1B,SAAT,EACI,MAAM,IAAIyB,KAAJ,CAAW,yDAAwD,KAAKjB,MAAL,CAAYmB,GAAZ,EAAkB,iCAArF,CAAN;AACJ,WAAO,KAAK7B,eAAZ;AACH;;AACK8B,EAAAA,cAAc,CAACC,YAAD,EAAe,GAAGC,IAAlB,EAAwB;AAAA;;AAAA;AACxC,YAAMf,OAAO,SAAS,MAAI,CAACW,gBAAL,EAAtB;AACA,aAAOX,OAAO,CAACa,cAAR,CAAuBC,YAAvB,EAAqC,GAAGC,IAAxC,CAAP;AAFwC;AAG3C;;AACKC,EAAAA,QAAQ,CAACF,YAAD,EAAe,GAAGC,IAAlB,EAAwB;AAAA;;AAAA;AAClC,YAAMf,OAAO,SAAS,MAAI,CAACW,gBAAL,EAAtB;AACA,aAAOX,OAAO,CAACgB,QAAR,CAAiBF,YAAjB,EAA+B,GAAGC,IAAlC,CAAP;AAFkC;AAGrC;;AACKE,EAAAA,CAAC,CAACC,QAAD,EAAW;AAAA;;AAAA;AACd,YAAMC,QAAQ,SAAS,MAAI,CAACC,SAAL,EAAvB;AACA,YAAMC,KAAK,SAASF,QAAQ,CAACF,CAAT,CAAWC,QAAX,CAApB;AACA,aAAOG,KAAP;AAHc;AAIjB;;AACKD,EAAAA,SAAS,GAAG;AAAA;;AAAA;AACd,UAAI,MAAI,CAACtC,gBAAT,EACI,OAAO,MAAI,CAACA,gBAAZ;AACJ,MAAA,MAAI,CAACA,gBAAL,GAAwB,MAAI,CAAC6B,gBAAL,GAAwBW,IAAxB;AAAA,qCAA6B,WAAOtB,OAAP,EAAmB;AACpE,gBAAMmB,QAAQ,SAASnB,OAAO,CAACa,cAAR,CAAuB,UAAvB,CAAvB;AACA,iBAAOM,QAAQ,CAACI,SAAT,EAAP;AACH,SAHuB;;AAAA;AAAA;AAAA;AAAA,UAAxB;AAIA,aAAO,MAAI,CAACzC,gBAAZ;AAPc;AAQjB;;AACK0C,EAAAA,EAAE,CAACC,UAAD,EAAa;AAAA;;AAAA;AACjB,YAAMN,QAAQ,SAAS,MAAI,CAACC,SAAL,EAAvB;AACA,YAAMC,KAAK,SAASF,QAAQ,CAACK,EAAT,CAAYC,UAAZ,CAApB;AACA,aAAOJ,KAAP;AAHiB;AAIpB;;AACKK,EAAAA,KAAK,CAACR,QAAD,EAAWJ,YAAX,EAAyB,GAAGC,IAA5B,EAAkC;AAAA;;AAAA;AACzC,YAAMI,QAAQ,SAAS,MAAI,CAACC,SAAL,EAAvB;AACA,aAAOD,QAAQ,CAACO,KAAT,CAAeR,QAAf,EAAyBJ,YAAzB,EAAuC,GAAGC,IAA1C,CAAP;AAFyC;AAG5C;;AACKY,EAAAA,MAAM,CAACT,QAAD,EAAWJ,YAAX,EAAyB,GAAGC,IAA5B,EAAkC;AAAA;;AAAA;AAC1C,YAAMI,QAAQ,SAAS,MAAI,CAACC,SAAL,EAAvB;AACA,YAAMC,KAAK,SAASF,QAAQ,CAACQ,MAAT,CAAgBT,QAAhB,EAA0BJ,YAA1B,EAAwC,GAAGC,IAA3C,CAApB;AACA,aAAOM,KAAP;AAH0C;AAI7C;;AACKO,EAAAA,EAAE,CAACV,QAAD,EAAW;AAAA;;AAAA;AACf,YAAMC,QAAQ,SAAS,MAAI,CAACC,SAAL,EAAvB;AACA,YAAMC,KAAK,SAASF,QAAQ,CAACS,EAAT,CAAYV,QAAZ,CAApB;AACA,aAAOG,KAAP;AAHe;AAIlB;;AACKQ,EAAAA,OAAO,GAAG;AAAA;;AAAA;AACZ,mBAAa,OAAI,CAACb,QAAL,CAAc,MAAM;AAC7B,YAAIc,MAAM,GAAG,EAAb;AACA,YAAIX,QAAQ,CAACY,OAAb,EACID,MAAM,GAAG,IAAIE,aAAJ,GAAoBC,iBAApB,CAAsCd,QAAQ,CAACY,OAA/C,CAAT;AACJ,YAAIZ,QAAQ,CAACe,eAAb,EACIJ,MAAM,IAAIX,QAAQ,CAACe,eAAT,CAAyBC,SAAnC;AACJ,eAAOL,MAAP;AACH,OAPY,CAAb;AADY;AASf;;AACKM,EAAAA,UAAU,CAACC,IAAD,EAAOC,OAAO,GAAG,EAAjB,EAAqB;AAAA;;AAAA;AACjC,YAAM;AAAEC,QAAAA,SAAS,GAAG,CAAC,MAAD,CAAd;AAAwBC,QAAAA,OAAO,GAAG,OAAI,CAAC9C,gBAAL,CAAsB+C,iBAAtB;AAAlC,UAAiFH,OAAvF,CADiC,CAEjC;AACA;;AACA,YAAM,OAAI,CAACtB,QAAL,CAAeqB,IAAD,IAAU;AAC1BlB,QAAAA,QAAQ,CAACuB,IAAT;AACAvB,QAAAA,QAAQ,CAACwB,KAAT,CAAeN,IAAf;AACAlB,QAAAA,QAAQ,CAACyB,KAAT;AACH,OAJK,EAIHP,IAJG,CAAN;AAKA,YAAMQ,OAAO,GAAG,IAAIxE,gBAAJ,CAAqB,OAAI,CAACmB,aAA1B,EAAyC,OAAI,CAACC,MAA9C,EAAsD8C,SAAtD,EAAiEC,OAAjE,CAAhB;AACA,YAAMM,KAAK,SAASzC,OAAO,CAAC0C,IAAR,CAAa,CAC7BF,OAAO,CAACG,2BAAR,EAD6B,EAE7BH,OAAO,CAACI,gBAAR,EAF6B,CAAb,CAApB;AAIAJ,MAAAA,OAAO,CAACK,OAAR;AACA,UAAIJ,KAAJ,EACI,MAAMA,KAAN;AAhB6B;AAiBpC;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUK,EAAAA,YAAY,CAACb,OAAD,EAAU;AAAA;;AAAA;AACxB,YAAM;AAAE1B,QAAAA,GAAG,GAAG,IAAR;AAAcwC,QAAAA,IAAI,GAAG,IAArB;AAA2BvB,QAAAA,OAAO,GAAG,IAArC;AAA2CwB,QAAAA,IAAI,GAAG;AAAlD,UAAyDf,OAA/D;;AACA,UAAI1B,GAAG,KAAK,IAAZ,EAAkB;AACd,YAAI;AACA,gBAAMZ,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,iBAAO,OAAOX,OAAO,CAACa,cAAR,CAAuByC,YAAvB,EAAqC1C,GAArC,EAA0CyC,IAA1C,CAAP,EAAwD9B,SAAxD,EAAP;AACH,SAHD,CAIA,OAAOuB,KAAP,EAAc;AACV,gBAAM,IAAIpC,KAAJ,CAAW,uBAAsBE,GAAI,SAArC,CAAN;AACH;AACJ;;AACD,UAAIwC,IAAI,KAAK,IAAb,EAAmB;AACf,YAAI,CAAC5E,MAAL,EAAa;AACT,gBAAM,IAAIkC,KAAJ,CAAU,oEAAV,CAAN;AACH;;AACD,cAAM6C,EAAE,SAASpF,MAAM,CAACqF,cAAP,EAAjB;AACA,YAAIC,QAAQ,SAASF,EAAE,CAACG,QAAH,CAAYC,QAAZ,CAAqBP,IAArB,EAA2B,MAA3B,CAArB;AACAK,QAAAA,QAAQ,IAAI,mBAAmBL,IAAI,CAACQ,OAAL,CAAa,KAAb,EAAoB,EAApB,CAA/B;AACA,cAAM5D,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,eAAO,OAAOX,OAAO,CAACa,cAAR,CAAuBgD,gBAAvB,EAAyCJ,QAAzC,EAAmDJ,IAAnD,CAAP,EAAiE9B,SAAjE,EAAP;AACH;;AACD,UAAIM,OAAO,KAAK,IAAhB,EAAsB;AAClB,cAAM7B,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,eAAO,OAAOX,OAAO,CAACa,cAAR,CAAuBgD,gBAAvB,EAAyChC,OAAzC,EAAkDwB,IAAlD,CAAP,EAAgE9B,SAAhE,EAAP;AACH;;AACD,YAAM,IAAIb,KAAJ,CAAU,8DAAV,CAAN;;AAzBwB,eA0BT4C,YA1BS;AAAA;AAAA;;AAAA;AAAA,0CA0BxB,WAA4B1C,GAA5B,EAAiCyC,IAAjC,EAAuC;AACnC,gBAAMS,MAAM,GAAG3C,QAAQ,CAAC4C,aAAT,CAAuB,QAAvB,CAAf;AACAD,UAAAA,MAAM,CAACE,GAAP,GAAapD,GAAb;AACA,cAAIyC,IAAJ,EACIS,MAAM,CAACT,IAAP,GAAcA,IAAd;AACJ,gBAAMY,OAAO,GAAG,IAAI5D,OAAJ,CAAY,CAAC6D,GAAD,EAAMC,GAAN,KAAc;AACtCL,YAAAA,MAAM,CAACM,MAAP,GAAgBF,GAAhB;AACAJ,YAAAA,MAAM,CAACO,OAAP,GAAiBF,GAAjB;AACH,WAHe,CAAhB;AAIAhD,UAAAA,QAAQ,CAACmD,IAAT,CAAcC,WAAd,CAA0BT,MAA1B;AACA,gBAAMG,OAAN;AACA,iBAAOH,MAAP;AACH,SAtCuB;AAAA;AAAA;;AAuCxB,eAASD,gBAAT,CAA0BhC,OAA1B,EAAmCwB,IAAI,GAAG,iBAA1C,EAA6D;AACzD,cAAMS,MAAM,GAAG3C,QAAQ,CAAC4C,aAAT,CAAuB,QAAvB,CAAf;AACAD,QAAAA,MAAM,CAACT,IAAP,GAAcA,IAAd;AACAS,QAAAA,MAAM,CAACU,IAAP,GAAc3C,OAAd;AACA,YAAIiB,KAAK,GAAG,IAAZ;;AACAgB,QAAAA,MAAM,CAACO,OAAP,GAAkBI,CAAD,IAAQ3B,KAAK,GAAG2B,CAAjC;;AACAtD,QAAAA,QAAQ,CAACmD,IAAT,CAAcC,WAAd,CAA0BT,MAA1B;AACA,YAAIhB,KAAJ,EACI,MAAMA,KAAN;AACJ,eAAOgB,MAAP;AACH;AAjDuB;AAkD3B;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUY,EAAAA,WAAW,CAACpC,OAAD,EAAU;AAAA;;AAAA;AACvB,YAAM;AAAE1B,QAAAA,GAAG,GAAG,IAAR;AAAcwC,QAAAA,IAAI,GAAG,IAArB;AAA2BvB,QAAAA,OAAO,GAAG;AAArC,UAA8CS,OAApD;;AACA,UAAI1B,GAAG,KAAK,IAAZ,EAAkB;AACd,YAAI;AACA,gBAAMZ,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,iBAAO,OAAOX,OAAO,CAACa,cAAR,CAAuB8D,WAAvB,EAAoC/D,GAApC,CAAP,EAAiDW,SAAjD,EAAP;AACH,SAHD,CAIA,OAAOuB,KAAP,EAAc;AACV,gBAAM,IAAIpC,KAAJ,CAAW,sBAAqBE,GAAI,SAApC,CAAN;AACH;AACJ;;AACD,UAAIwC,IAAI,KAAK,IAAb,EAAmB;AACf,YAAI,CAAC5E,MAAL,EAAa;AACT,gBAAM,IAAIkC,KAAJ,CAAU,mEAAV,CAAN;AACH;;AACD,cAAM6C,EAAE,SAASpF,MAAM,CAACqF,cAAP,EAAjB;AACA,YAAIC,QAAQ,SAASF,EAAE,CAACG,QAAH,CAAYC,QAAZ,CAAqBP,IAArB,EAA2B,MAA3B,CAArB;AACAK,QAAAA,QAAQ,IAAI,mBAAmBL,IAAI,CAACQ,OAAL,CAAa,KAAb,EAAoB,EAApB,CAAnB,GAA6C,IAAzD;AACA,cAAM5D,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,eAAO,OAAOX,OAAO,CAACa,cAAR,CAAuB+D,eAAvB,EAAwCnB,QAAxC,CAAP,EAA0DlC,SAA1D,EAAP;AACH;;AACD,UAAIM,OAAO,KAAK,IAAhB,EAAsB;AAClB,cAAM7B,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;AACA,eAAO,OAAOX,OAAO,CAACa,cAAR,CAAuB+D,eAAvB,EAAwC/C,OAAxC,CAAP,EAAyDN,SAAzD,EAAP;AACH;;AACD,YAAM,IAAIb,KAAJ,CAAU,8DAAV,CAAN;;AAzBuB,eA0BRiE,WA1BQ;AAAA;AAAA;;AAAA;AAAA,yCA0BvB,WAA2B/D,GAA3B,EAAgC;AAC5B,gBAAMiE,IAAI,GAAG1D,QAAQ,CAAC4C,aAAT,CAAuB,MAAvB,CAAb;AACAc,UAAAA,IAAI,CAACC,GAAL,GAAW,YAAX;AACAD,UAAAA,IAAI,CAACE,IAAL,GAAYnE,GAAZ;AACA,gBAAMqD,OAAO,GAAG,IAAI5D,OAAJ,CAAY,CAAC6D,GAAD,EAAMC,GAAN,KAAc;AACtCU,YAAAA,IAAI,CAACT,MAAL,GAAcF,GAAd;AACAW,YAAAA,IAAI,CAACR,OAAL,GAAeF,GAAf;AACH,WAHe,CAAhB;AAIAhD,UAAAA,QAAQ,CAACmD,IAAT,CAAcC,WAAd,CAA0BM,IAA1B;AACA,gBAAMZ,OAAN;AACA,iBAAOY,IAAP;AACH,SArCsB;AAAA;AAAA;;AAAA,eAsCRD,eAtCQ;AAAA;AAAA;;AAAA;AAAA,6CAsCvB,WAA+B/C,OAA/B,EAAwC;AACpC,gBAAMmD,KAAK,GAAG7D,QAAQ,CAAC4C,aAAT,CAAuB,OAAvB,CAAd;AACAiB,UAAAA,KAAK,CAAC3B,IAAN,GAAa,UAAb;AACA2B,UAAAA,KAAK,CAACT,WAAN,CAAkBpD,QAAQ,CAAC8D,cAAT,CAAwBpD,OAAxB,CAAlB;AACA,gBAAMoC,OAAO,GAAG,IAAI5D,OAAJ,CAAY,CAAC6D,GAAD,EAAMC,GAAN,KAAc;AACtCa,YAAAA,KAAK,CAACZ,MAAN,GAAeF,GAAf;AACAc,YAAAA,KAAK,CAACX,OAAN,GAAgBF,GAAhB;AACH,WAHe,CAAhB;AAIAhD,UAAAA,QAAQ,CAACmD,IAAT,CAAcC,WAAd,CAA0BS,KAA1B;AACA,gBAAMf,OAAN;AACA,iBAAOe,KAAP;AACH,SAjDsB;AAAA;AAAA;AAAA;AAkD1B;;AACKE,EAAAA,KAAK,CAAChE,QAAD,EAAWoB,OAAX,EAAoB;AAAA;;AAAA;AAC3B,YAAM6C,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACAhD,MAAAA,MAAM,CAACiH,MAAD,EAAS,iCAAiCjE,QAA1C,CAAN;AACA,YAAMiE,MAAM,CAACD,KAAP,CAAa5C,OAAb,CAAN;AACA,YAAM6C,MAAM,CAACjC,OAAP,EAAN;AAJ2B;AAK9B;;AACKkC,EAAAA,KAAK,CAAClE,QAAD,EAAW;AAAA;;AAAA;AAClB,YAAMiE,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACAhD,MAAAA,MAAM,CAACiH,MAAD,EAAS,iCAAiCjE,QAA1C,CAAN;AACA,YAAMiE,MAAM,CAACC,KAAP,EAAN;AACA,YAAMD,MAAM,CAACjC,OAAP,EAAN;AAJkB;AAKrB;;AACKmC,EAAAA,KAAK,CAACnE,QAAD,EAAW;AAAA;;AAAA;AAClB,YAAMiE,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACAhD,MAAAA,MAAM,CAACiH,MAAD,EAAS,iCAAiCjE,QAA1C,CAAN;AACA,YAAMiE,MAAM,CAACE,KAAP,EAAN;AACA,YAAMF,MAAM,CAACjC,OAAP,EAAN;AAJkB;AAKrB;;AACKoC,EAAAA,MAAM,CAACpE,QAAD,EAAW,GAAGqE,MAAd,EAAsB;AAAA;;AAAA;AAC9B,YAAMJ,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACAhD,MAAAA,MAAM,CAACiH,MAAD,EAAS,iCAAiCjE,QAA1C,CAAN;AACA,YAAMsE,MAAM,SAASL,MAAM,CAACG,MAAP,CAAc,GAAGC,MAAjB,CAArB;AACA,YAAMJ,MAAM,CAACjC,OAAP,EAAN;AACA,aAAOsC,MAAP;AAL8B;AAMjC;;AACKC,EAAAA,GAAG,CAACvE,QAAD,EAAW;AAAA;;AAAA;AAChB,YAAMiE,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACA,YAAMiE,MAAM,CAACM,GAAP,EAAN;AACA,YAAMN,MAAM,CAACjC,OAAP,EAAN;AAHgB;AAInB;;AACKG,EAAAA,IAAI,CAACnC,QAAD,EAAWsD,IAAX,EAAiBlC,OAAjB,EAA0B;AAAA;;AAAA;AAChC,YAAM6C,MAAM,SAAS,OAAI,CAAClE,CAAL,CAAOC,QAAP,CAArB;AACAhD,MAAAA,MAAM,CAACiH,MAAD,EAAS,iCAAiCjE,QAA1C,CAAN;AACA,YAAMiE,MAAM,CAAC9B,IAAP,CAAYmB,IAAZ,EAAkBlC,OAAlB,CAAN;AACA,YAAM6C,MAAM,CAACjC,OAAP,EAAN;AAJgC;AAKnC;;AACKwC,EAAAA,eAAe,CAACxE,QAAD,EAAWoB,OAAX,EAAoB;AAAA;;AAAA;AACrC,YAAM;AAAEqD,QAAAA,eAAF;AAAmBC,QAAAA;AAAnB,UAAoCrH,0BAA0B,CAAC2C,QAAD,CAApE;AACA,aAAO0E,YAAY,CAACC,OAAb,CAAqB,OAArB,EAA2BF,eAA3B,EAA4CrD,OAA5C,CAAP;AAFqC;AAGxC;AACD;AACJ;AACA;;;AACUwD,EAAAA,mBAAmB,CAAC9F,OAAD,EAAU+F,IAAV,EAAgB;AAAA;;AAAA;AACrC;AACA,UAAI,OAAI,CAACzG,YAAL,CAAkB0G,GAAlB,CAAsBvH,QAAQ,CAACwH,iBAAT,CAA2BF,IAA3B,EAAiC/F,OAAO,CAACkG,UAAzC,CAAtB,CAAJ,EAAiF;AAC7E;AACH,OAJoC,CAKrC;;;AACA,UAAI,OAAI,CAAC3G,iBAAT,EAA4B;AACxB,cAAM,OAAI,CAACA,iBAAX;AACA,eAAO,OAAI,CAACuG,mBAAL,CAAyB9F,OAAzB,EAAkC+F,IAAlC,CAAP;AACH;;AACD,YAAMI,IAAI;AAAA,sCAAG,WAAOJ,IAAP,EAAgB;AACzB,gBAAMtE,UAAU,GAAGtD,MAAM,CAACiI,qBAAP,CAA6B,UAA7B,EAAyCL,IAAzC,CAAnB;;AACA,cAAI;AACA;AACA,kBAAM/F,OAAO,CAACJ,OAAR,CAAgByG,IAAhB,CAAqB,oBAArB,EAA2C;AAC7CN,cAAAA,IAD6C;AAE7C;AACA;AACAO,cAAAA,oBAAoB,EAAEtG,OAAO,CAACuG;AAJe,aAA3C,CAAN;AAMA,kBAAMvG,OAAO,CAACgB,QAAR,CAAiBS,UAAjB,CAAN;AACH,WATD,CAUA,OAAOqB,KAAP,EAAc;AACV;AACA;AACA;AACA,kBAAM0D,YAAY,GAAG1D,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,iCAAvB,CAArB;AACA,kBAAMC,WAAW,GAAG7D,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,uCAAvB,CAApB;;AACA,gBAAIF,YAAY,IAAIG,WAApB,EAAiC;AAC7B;AACH,aAFD,MAGK;AACDvI,cAAAA,UAAU,CAAC0E,KAAD,CAAV;AACA;AACH;AACJ;;AACD,UAAA,OAAI,CAACxD,YAAL,CAAkBsH,GAAlB,CAAsBnI,QAAQ,CAACwH,iBAAT,CAA2BF,IAA3B,EAAiC/F,OAAO,CAACkG,UAAzC,CAAtB;AACH,SA3BS;;AAAA,wBAAJC,IAAI;AAAA;AAAA;AAAA,SAAV;;AA4BA,MAAA,OAAI,CAAC5G,iBAAL,GAAyB4G,IAAI,CAACJ,IAAD,CAA7B;AACA,YAAM,OAAI,CAACxG,iBAAX;AACA,MAAA,OAAI,CAACA,iBAAL,GAAyB,IAAzB;AAxCqC;AAyCxC;;AACKQ,EAAAA,gBAAgB,CAACD,KAAD,EAAQ;AAAA;;AAAA;AAC1B,UAAI+G,OAAJ;AACA,UAAI,CAAC,OAAI,CAACtG,WAAL,EAAL,EACI;AACJ,YAAMP,OAAO,SAAS,OAAI,CAACW,gBAAL,EAAtB;;AACA,UAAI;AACAkG,QAAAA,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWjH,KAAK,CAAC+G,OAAjB,CAAV;AACH,OAFD,CAGA,MAAM;AACF;AACA;AACA;AACH;;AACD,YAAM;AAAExD,QAAAA,IAAF;AAAQ0C,QAAAA,IAAR;AAAciB,QAAAA,GAAd;AAAmBjG,QAAAA;AAAnB,UAA4B8F,OAAlC;AACA,UAAIxD,IAAI,KAAK,UAAT,IACA,CAAC,OAAI,CAAC/D,YAAL,CAAkB0G,GAAlB,CAAsBvH,QAAQ,CAACwH,iBAAT,CAA2BF,IAA3B,EAAiC/F,OAAO,CAACkG,UAAzC,CAAtB,CADL,EAEI;AACJ,UAAIlG,OAAO,CAACkG,UAAR,KAAuBpG,KAAK,CAACmH,kBAAjC,EACI;;AACJ,UAAI;AACA,cAAMzB,MAAM,SAAS,OAAI,CAACpG,eAAL,CAAqB8H,GAArB,CAAyBnB,IAAzB,EAA+B,GAAGhF,IAAlC,CAArB;AACA,cAAMf,OAAO,CAACgB,QAAR,CAAiBmG,aAAjB,EAAgCpB,IAAhC,EAAsCiB,GAAtC,EAA2CxB,MAA3C,CAAN;AACH,OAHD,CAIA,OAAO1C,KAAP,EAAc;AACV;AACA;AACA;AACA;AACA;AACA,YAAIA,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,gBAAvB,CAAJ,EACI;AACJtI,QAAAA,UAAU,CAAC0E,KAAD,CAAV;AACH;;AACD,eAASqE,aAAT,CAAuBpB,IAAvB,EAA6BiB,GAA7B,EAAkCxB,MAAlC,EAA0C;AACtC4B,QAAAA,UAAU,CAACrB,IAAD,CAAV,CAAiBsB,SAAjB,CAA2BH,GAA3B,CAA+BF,GAA/B,EAAoCM,OAApC,CAA4C9B,MAA5C;AACA4B,QAAAA,UAAU,CAACrB,IAAD,CAAV,CAAiBsB,SAAjB,CAA2BE,MAA3B,CAAkCP,GAAlC;AACH;AApCyB;AAqC7B;AACD;AACJ;AACA;;;AACUQ,EAAAA,qBAAqB,CAACC,QAAD,EAAWvG,QAAX,EAAqBoB,OAArB,EAA8BoF,OAA9B,EAAuC;AAAA;;AAAA;AAC9D,YAAM;AAAEC,QAAAA,OAAO,EAAEC,cAAc,GAAG,KAA5B;AAAmCC,QAAAA,MAAM,EAAEC,aAAa,GAAG,KAA3D;AAAkEtF,QAAAA,OAAO,GAAG,OAAI,CAAC9C,gBAAL,CAAsB8C,OAAtB;AAA5E,UAAiHF,OAAvH;AACA,YAAMyF,OAAO,GAAGH,cAAc,IAAIE,aAAlB,GAAkC,KAAlC,GAA0C,UAA1D;AACA,YAAME,KAAK,GAAI,cAAa9G,QAAS,KAAI4G,aAAa,GAAG,eAAH,GAAqB,EAAG,EAA9E;;AAH8D,eAI/CG,SAJ+C;AAAA;AAAA;;AAAA;AAAA,uCAI9D,WAAyB/G,QAAzB,EAAmC0G,cAAnC,EAAmDE,aAAnD,EAAkE;AAC9D,gBAAMI,IAAI,GAAGC,qBAAqB,SACrBA,qBAAqB,CAAChH,QAAD,EAAWD,QAAX,CADA,GAE5BC,QAAQ,CAACiH,aAAT,CAAuBlH,QAAvB,CAFN;AAGA,iBAAOmH,mBAAmB,CAACH,IAAD,EAAON,cAAP,EAAuBE,aAAvB,CAA1B;AACH,SAT6D;AAAA;AAAA;;AAU9D,YAAMQ,eAAe,GAAG;AACpBC,QAAAA,QAAQ,EAAE,OADU;AAEpBC,QAAAA,aAAa,EAAErK,MAAM,CAACsK,mBAAP,CAA2BR,SAA3B,EAAsCR,QAAtC,CAFK;AAGpBO,QAAAA,KAHoB;AAIpBD,QAAAA,OAJoB;AAKpBvF,QAAAA,OALoB;AAMpBzB,QAAAA,IAAI,EAAE,CAACG,QAAD,EAAW0G,cAAX,EAA2BE,aAA3B,CANc;AAOpBJ,QAAAA;AAPoB,OAAxB;AASA,YAAMvH,QAAQ,GAAG,IAAIuI,QAAJ,CAAaJ,eAAb,CAAjB;AACA,YAAMK,QAAQ,SAASxI,QAAQ,CAAC8D,OAAhC;AACA,YAAM2E,aAAa,GAAGD,QAAQ,CAACpH,SAAT,EAAtB;;AACA,UAAI,CAACqH,aAAL,EAAoB;AAChB,cAAMD,QAAQ,CAACzF,OAAT,EAAN;AACA,eAAO,IAAP;AACH;;AACD,aAAO0F,aAAP;AA1B8D;AA2BjE;;AACKC,EAAAA,YAAY,CAACC,KAAD,EAAQxG,OAAR,EAAiB;AAAA;;AAAA;AAC/B,YAAM;AAAEqF,QAAAA,OAAO,EAAEC,cAAc,GAAG,KAA5B;AAAmCC,QAAAA,MAAM,EAAEC,aAAa,GAAG,KAA3D;AAAkEtF,QAAAA,OAAO,GAAG,OAAI,CAAC9C,gBAAL,CAAsB8C,OAAtB;AAA5E,UAAiHF,OAAvH;AACA,YAAMyF,OAAO,GAAGH,cAAc,IAAIE,aAAlB,GAAkC,KAAlC,GAA0C,UAA1D;AACA,YAAME,KAAK,GAAI,WAAUc,KAAM,KAAIhB,aAAa,GAAG,eAAH,GAAqB,EAAG,EAAxE;;AACA,eAASG,SAAT,CAAmBa,KAAnB,EAA0BlB,cAA1B,EAA0CE,aAA1C,EAAyD;AACrD,cAAMI,IAAI,GAAG/G,QAAQ,CAACH,QAAT,CAAkB8H,KAAlB,EAAyB3H,QAAzB,EAAmC,IAAnC,EAAyC4H,WAAW,CAACC,uBAArD,EAA8E,IAA9E,EAAoFC,eAAjG;AACA,eAAOZ,mBAAmB,CAACH,IAAD,EAAON,cAAP,EAAuBE,aAAvB,CAA1B;AACH;;AACD,YAAMQ,eAAe,GAAG;AACpBC,QAAAA,QAAQ,EAAE,OADU;AAEpBC,QAAAA,aAAa,EAAErK,MAAM,CAACsK,mBAAP,CAA2BR,SAA3B,CAFK;AAGpBD,QAAAA,KAHoB;AAIpBD,QAAAA,OAJoB;AAKpBvF,QAAAA,OALoB;AAMpBzB,QAAAA,IAAI,EAAE,CAAC+H,KAAD,EAAQlB,cAAR,EAAwBE,aAAxB;AANc,OAAxB;AAQA,YAAM3H,QAAQ,GAAG,IAAIuI,QAAJ,CAAaJ,eAAb,CAAjB;AACA,YAAMK,QAAQ,SAASxI,QAAQ,CAAC8D,OAAhC;AACA,YAAM2E,aAAa,GAAGD,QAAQ,CAACpH,SAAT,EAAtB;;AACA,UAAI,CAACqH,aAAL,EAAoB;AAChB,cAAMD,QAAQ,CAACzF,OAAT,EAAN;AACA,eAAO,IAAP;AACH;;AACD,aAAO0F,aAAP;AAvB+B;AAwBlC;;AACDM,EAAAA,eAAe,CAACpI,YAAD,EAAewB,OAAO,GAAG,EAAzB,EAA6B,GAAGvB,IAAhC,EAAsC;AACjD,UAAM;AAAEgH,MAAAA,OAAO,GAAG,KAAZ;AAAmBvF,MAAAA,OAAO,GAAG,KAAK9C,gBAAL,CAAsB8C,OAAtB;AAA7B,QAAiEF,OAAvE;AACA,UAAMgG,eAAe,GAAG;AACpBC,MAAAA,QAAQ,EAAE,IADU;AAEpBC,MAAAA,aAAa,EAAE1H,YAFK;AAGpBkH,MAAAA,KAAK,EAAE,UAHa;AAIpBD,MAAAA,OAJoB;AAKpBvF,MAAAA,OALoB;AAMpBzB,MAAAA;AANoB,KAAxB;AAQA,UAAMZ,QAAQ,GAAG,IAAIuI,QAAJ,CAAaJ,eAAb,CAAjB;AACA,WAAOnI,QAAQ,CAAC8D,OAAhB;AACH;;AACK+D,EAAAA,KAAK,GAAG;AAAA;;AAAA;AACV,aAAO,OAAI,CAAChH,QAAL,CAAc,MAAMG,QAAQ,CAAC6G,KAA7B,CAAP;AADU;AAEb;;AAzbiB;;AA2btBvJ,QAAQ,CAACwH,iBAAT,GAA6B,CAACF,IAAD,EAAOoD,SAAP,KAAsB,GAAEpD,IAAK,IAAGoD,SAAU,EAAvE;AACA;AACA;AACA;;;AACA,OAAO,MAAMT,QAAN,CAAe;AAClBhK,EAAAA,WAAW,CAAC4D,OAAD,EAAU;AACjB,SAAK8G,SAAL,GAAiB,CAAjB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,QAAIlL,MAAM,CAACmL,QAAP,CAAgBhH,OAAO,CAACyF,OAAxB,CAAJ,EACI7J,MAAM,CAACoE,OAAO,CAACyF,OAAR,KAAoB,KAApB,IAA6BzF,OAAO,CAACyF,OAAR,KAAoB,UAAlD,EAA8D,6BAA6BzF,OAAO,CAACyF,OAAnG,CAAN,CADJ,KAEK,IAAI5J,MAAM,CAACoL,QAAP,CAAgBjH,OAAO,CAACyF,OAAxB,CAAJ,EACD7J,MAAM,CAACoE,OAAO,CAACyF,OAAR,GAAkB,CAAnB,EAAsB,6CAA6CzF,OAAO,CAACyF,OAA3E,CAAN,CADC,KAGD,MAAM,IAAIrH,KAAJ,CAAU,8BAA8B4B,OAAO,CAACyF,OAAhD,CAAN;;AACJ,aAASyB,gBAAT,CAA0BhB,aAA1B,EAAyC;AACrC,UAAIrK,MAAM,CAACmL,QAAP,CAAgBd,aAAhB,CAAJ,EACI,OAAQ,WAAUA,aAAc,IAAhC;AACJ,aAAQ,WAAUA,aAAc,aAAhC;AACH;;AACD,SAAKiB,SAAL,GAAiBnH,OAAO,CAACiG,QAAzB;AACA,SAAKmB,QAAL,GAAgBpH,OAAO,CAACyF,OAAxB;AACA,SAAK4B,QAAL,GAAgBrH,OAAO,CAACE,OAAxB;AACA,SAAKoH,cAAL,GAAsBJ,gBAAgB,CAAClH,OAAO,CAACkG,aAAT,CAAtC;AACA,SAAKqB,KAAL,GAAavH,OAAO,CAACvB,IAArB;AACA,SAAK+I,QAAL,GAAgBxH,OAAO,CAACoF,OAAxB;AACA,SAAK0B,SAAL,GAAiB,CAAjB;;AACA,SAAKK,SAAL,CAAevK,UAAf,CAA0B0H,GAA1B,CAA8B,IAA9B;;AACA,QAAI,KAAKkD,QAAT,EAAmB;AACf,WAAKL,SAAL,CAAerK,eAAf,CAA+B2K,GAA/B,CAAmC,KAAKD,QAAL,CAAc/D,IAAjD,EAAuD,KAAK+D,QAAL,CAAcE,YAArE;AACH;;AACD,SAAK/F,OAAL,GAAe,IAAI5D,OAAJ,CAAY,CAACiH,OAAD,EAAU2C,MAAV,KAAqB;AAC5C,WAAKC,QAAL,GAAgB5C,OAAhB;AACA,WAAK6C,OAAL,GAAeF,MAAf;AACH,KAHc,CAAf,CAzBiB,CA6BjB;AACA;;AACA,QAAI3H,OAAO,CAACE,OAAZ,EAAqB;AACjB,YAAM4H,YAAY,GAAG,IAAI9L,YAAJ,CAAkB,eAAcgE,OAAO,CAAC0F,KAAM,oBAAmB1F,OAAO,CAACE,OAAQ,aAAjF,CAArB;AACA,WAAK6H,aAAL,GAAqBC,UAAU,CAAC,MAAM,KAAK7J,SAAL,CAAe2J,YAAf,CAAP,EAAqC9H,OAAO,CAACE,OAA7C,CAA/B;AACH;;AACD,SAAKpC,KAAL;AACH;;AACDK,EAAAA,SAAS,CAACqC,KAAD,EAAQ;AACb,SAAKuG,WAAL,GAAmB,IAAnB;;AACA,SAAKc,OAAL,CAAarH,KAAb;;AACA,SAAKyH,QAAL;AACH;;AACKnK,EAAAA,KAAK,GAAG;AAAA;;AAAA;AACV,YAAMoK,QAAQ,GAAG,EAAE,OAAI,CAACpB,SAAxB;AACA,UAAIqB,OAAO,GAAG,IAAd;AACA,UAAI3H,KAAK,GAAG,IAAZ;AACA,YAAM9C,OAAO,SAAS,OAAI,CAACyJ,SAAL,CAAe9I,gBAAf,EAAtB;AACA,UAAI,OAAI,CAAC0I,WAAL,IAAoBmB,QAAQ,KAAK,OAAI,CAACpB,SAA1C,EACI;;AACJ,UAAI,OAAI,CAACU,QAAT,EAAmB;AACf,cAAM,OAAI,CAACL,SAAL,CAAe3D,mBAAf,CAAmC9F,OAAnC,EAA4C,OAAI,CAAC8J,QAAL,CAAc/D,IAA1D,CAAN;AACH;;AACD,UAAI,OAAI,CAACsD,WAAL,IAAoBmB,QAAQ,KAAK,OAAI,CAACpB,SAA1C,EACI;;AACJ,UAAI;AACAqB,QAAAA,OAAO,SAASzK,OAAO,CAACa,cAAR,CAAuB6J,4BAAvB,EAAqD,OAAI,CAACd,cAA1D,EAA0E,OAAI,CAACF,QAA/E,EAAyF,OAAI,CAACC,QAA9F,EAAwG,GAAG,OAAI,CAACE,KAAhH,CAAhB;AACH,OAFD,CAGA,OAAOc,MAAP,EAAe;AACX7H,QAAAA,KAAK,GAAG6H,MAAR;AACH;;AACD,UAAI,OAAI,CAACtB,WAAL,IAAoBmB,QAAQ,KAAK,OAAI,CAACpB,SAA1C,EAAqD;AACjD,YAAIqB,OAAJ,EACI,MAAMA,OAAO,CAACvH,OAAR,EAAN;AACJ;AACH,OAtBS,CAuBV;AACA;AACA;;;AACA,UAAI,CAACJ,KAAD,WACO,OAAI,CAAC2G,SAAL,CAAezI,QAAf,CAAyB4J,CAAD,IAAO,CAACA,CAAhC,EAAmCH,OAAnC,EAA4CI,KAA5C,CAAkD,MAAM,IAAxD,CADP,CAAJ,EAC2E;AACvE,cAAMJ,OAAO,CAACvH,OAAR,EAAN;AACA;AACH;;AACD,UAAIJ,KAAJ,EAAW;AACP,YAAIA,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,sCAAvB,CAAJ,EAAoE;AAChE,iBAAO,OAAI,CAACtG,KAAL,EAAP;AACH,SAHM,CAIP;AACA;AACA;;;AACA,YAAI0C,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,sDAAvB,CAAJ,EAAoF;AAChF,UAAA,OAAI,CAACjG,SAAL,CAAe,IAAIC,KAAJ,CAAU,6CAAV,CAAf;;AACA;AACH,SAVM,CAWP;AACA;;;AACA,YAAIoC,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,iCAAvB,CAAJ,EACI,OAdG,CAeP;AACA;;AACA,YAAI5D,KAAK,CAAC2D,OAAN,CAAcC,QAAd,CAAuB,uCAAvB,CAAJ,EACI;;AACJ,QAAA,OAAI,CAACyD,OAAL,CAAarH,KAAb;AACH,OApBD,MAqBK;AACD,QAAA,OAAI,CAACoH,QAAL,CAAcO,OAAd;AACH;;AACD,MAAA,OAAI,CAACF,QAAL;AAvDU;AAwDb;;AACDA,EAAAA,QAAQ,GAAG;AACPO,IAAAA,YAAY,CAAC,KAAKT,aAAN,CAAZ;;AACA,SAAKZ,SAAL,CAAevK,UAAf,CAA0BqI,MAA1B,CAAiC,IAAjC;AACH;;AAvGiB;;SAyGPmD,4B;;EAyEf;;;;oDAzEA,WAA4ClC,aAA5C,EAA2DT,OAA3D,EAAoEvF,OAApE,EAA6E,GAAGzB,IAAhF,EAAsF;AAClF,UAAMkH,SAAS,GAAG,IAAI8C,QAAJ,CAAa,SAAb,EAAwBvC,aAAxB,CAAlB;AACA,QAAIwC,QAAQ,GAAG,KAAf;AACA,QAAIxI,OAAJ,EACI8H,UAAU,CAAC,MAAOU,QAAQ,GAAG,IAAnB,EAA0BxI,OAA1B,CAAV;AACJ,QAAIuF,OAAO,KAAK,KAAhB,EACI,aAAakD,OAAO,EAApB;AACJ,QAAIlD,OAAO,KAAK,UAAhB,EACI,aAAamD,YAAY,EAAzB;AACJ,QAAI,OAAOnD,OAAP,KAAmB,QAAvB,EACI,aAAaoD,YAAY,CAACpD,OAAD,CAAzB;AACJ;AACJ;AACA;;AAbsF,aAcnEmD,YAdmE;AAAA;AAAA;;AAAA;AAAA,wCAclF,aAA8B;AAC1B,cAAMT,OAAO,SAASxC,SAAS,CAAC,GAAGlH,IAAJ,CAA/B;AACA,YAAI0J,OAAJ,EACI,OAAOpK,OAAO,CAACiH,OAAR,CAAgBmD,OAAhB,CAAP;AACJ,YAAInK,OAAJ;AACA,cAAMkF,MAAM,GAAG,IAAInF,OAAJ,CAAa+K,CAAD,IAAQ9K,OAAO,GAAG8K,CAA9B,CAAf;AACA,cAAMC,QAAQ,GAAG,IAAIC,gBAAJ,iCAAqB,aAAY;AAC9C,cAAIN,QAAJ,EAAc;AACVK,YAAAA,QAAQ,CAACE,UAAT;AACAjL,YAAAA,OAAO;AACV;;AACD,gBAAMmK,OAAO,SAASxC,SAAS,CAAC,GAAGlH,IAAJ,CAA/B;;AACA,cAAI0J,OAAJ,EAAa;AACTY,YAAAA,QAAQ,CAACE,UAAT;AACAjL,YAAAA,OAAO,CAACmK,OAAD,CAAP;AACH;AACJ,SAVgB,EAAjB;AAWAY,QAAAA,QAAQ,CAACG,OAAT,CAAiBrK,QAAjB,EAA2B;AACvBsK,UAAAA,SAAS,EAAE,IADY;AAEvBC,UAAAA,OAAO,EAAE,IAFc;AAGvBC,UAAAA,UAAU,EAAE;AAHW,SAA3B;AAKA,eAAOnG,MAAP;AACH,OArCiF;AAAA;AAAA;;AAAA,aAsCnEyF,OAtCmE;AAAA;AAAA;;AAAA;AAAA,mCAsClF,aAAyB;AACrB,YAAI3K,OAAJ;AACA,cAAMkF,MAAM,GAAG,IAAInF,OAAJ,CAAa+K,CAAD,IAAQ9K,OAAO,GAAG8K,CAA9B,CAAf;AACA,cAAMQ,KAAK,EAAX;AACA,eAAOpG,MAAP;;AAJqB,iBAKNoG,KALM;AAAA;AAAA;;AAAA;AAAA,qCAKrB,aAAuB;AACnB,gBAAIZ,QAAJ,EAAc;AACV1K,cAAAA,OAAO;AACP;AACH;;AACD,kBAAMmK,OAAO,SAASxC,SAAS,CAAC,GAAGlH,IAAJ,CAA/B;AACA,gBAAI0J,OAAJ,EACInK,OAAO,CAACmK,OAAD,CAAP,CADJ,KAGIoB,qBAAqB,CAACD,KAAD,CAArB;AACP,WAfoB;AAAA;AAAA;AAgBxB,OAtDiF;AAAA;AAAA;;AAAA,aAuDnET,YAvDmE;AAAA;AAAA;;AAAA;AAAA,wCAuDlF,WAA4BA,YAA5B,EAA0C;AACtC,YAAI7K,OAAJ;AACA,cAAMkF,MAAM,GAAG,IAAInF,OAAJ,CAAa+K,CAAD,IAAQ9K,OAAO,GAAG8K,CAA9B,CAAf;AACA,cAAMU,SAAS,EAAf;AACA,eAAOtG,MAAP;;AAJsC,iBAKvBsG,SALuB;AAAA;AAAA;;AAAA;AAAA,yCAKtC,aAA2B;AACvB,gBAAId,QAAJ,EAAc;AACV1K,cAAAA,OAAO;AACP;AACH;;AACD,kBAAMmK,OAAO,SAASxC,SAAS,CAAC,GAAGlH,IAAJ,CAA/B;AACA,gBAAI0J,OAAJ,EACInK,OAAO,CAACmK,OAAD,CAAP,CADJ,KAGIH,UAAU,CAACwB,SAAD,EAAYX,YAAZ,CAAV;AACP,WAfqC;AAAA;AAAA;AAgBzC,OAvEiF;AAAA;AAAA;AAwErF,G","sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert.js';\nimport { helper, debugError } from './helper.js';\nimport { LifecycleWatcher, } from './LifecycleWatcher.js';\nimport { TimeoutError } from './Errors.js';\nimport { getQueryHandlerAndSelector } from './QueryHandler.js';\nimport { isNode } from '../environment.js';\n/**\n * @internal\n */\nexport class DOMWorld {\n    constructor(frameManager, frame, timeoutSettings) {\n        this._documentPromise = null;\n        this._contextPromise = null;\n        this._contextResolveCallback = null;\n        this._detached = false;\n        /**\n         * @internal\n         */\n        this._waitTasks = new Set();\n        /**\n         * @internal\n         * Contains mapping from functions that should be bound to Puppeteer functions.\n         */\n        this._boundFunctions = new Map();\n        // Set of bindings that have been registered in the current context.\n        this._ctxBindings = new Set();\n        // If multiple waitFor are set up asynchronously, we need to wait for the\n        // first one to set up the binding in the page before running the others.\n        this._settingUpBinding = null;\n        this._frameManager = frameManager;\n        this._frame = frame;\n        this._timeoutSettings = timeoutSettings;\n        this._setContext(null);\n        frameManager._client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));\n    }\n    frame() {\n        return this._frame;\n    }\n    async _setContext(context) {\n        if (context) {\n            this._ctxBindings.clear();\n            this._contextResolveCallback.call(null, context);\n            this._contextResolveCallback = null;\n            for (const waitTask of this._waitTasks)\n                waitTask.rerun();\n        }\n        else {\n            this._documentPromise = null;\n            this._contextPromise = new Promise((fulfill) => {\n                this._contextResolveCallback = fulfill;\n            });\n        }\n    }\n    _hasContext() {\n        return !this._contextResolveCallback;\n    }\n    _detach() {\n        this._detached = true;\n        for (const waitTask of this._waitTasks)\n            waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n    }\n    executionContext() {\n        if (this._detached)\n            throw new Error(`Execution context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n        return this._contextPromise;\n    }\n    async evaluateHandle(pageFunction, ...args) {\n        const context = await this.executionContext();\n        return context.evaluateHandle(pageFunction, ...args);\n    }\n    async evaluate(pageFunction, ...args) {\n        const context = await this.executionContext();\n        return context.evaluate(pageFunction, ...args);\n    }\n    async $(selector) {\n        const document = await this._document();\n        const value = await document.$(selector);\n        return value;\n    }\n    async _document() {\n        if (this._documentPromise)\n            return this._documentPromise;\n        this._documentPromise = this.executionContext().then(async (context) => {\n            const document = await context.evaluateHandle('document');\n            return document.asElement();\n        });\n        return this._documentPromise;\n    }\n    async $x(expression) {\n        const document = await this._document();\n        const value = await document.$x(expression);\n        return value;\n    }\n    async $eval(selector, pageFunction, ...args) {\n        const document = await this._document();\n        return document.$eval(selector, pageFunction, ...args);\n    }\n    async $$eval(selector, pageFunction, ...args) {\n        const document = await this._document();\n        const value = await document.$$eval(selector, pageFunction, ...args);\n        return value;\n    }\n    async $$(selector) {\n        const document = await this._document();\n        const value = await document.$$(selector);\n        return value;\n    }\n    async content() {\n        return await this.evaluate(() => {\n            let retVal = '';\n            if (document.doctype)\n                retVal = new XMLSerializer().serializeToString(document.doctype);\n            if (document.documentElement)\n                retVal += document.documentElement.outerHTML;\n            return retVal;\n        });\n    }\n    async setContent(html, options = {}) {\n        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n        // lifecycle event. @see https://crrev.com/608658\n        await this.evaluate((html) => {\n            document.open();\n            document.write(html);\n            document.close();\n        }, html);\n        const watcher = new LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);\n        const error = await Promise.race([\n            watcher.timeoutOrTerminationPromise(),\n            watcher.lifecyclePromise(),\n        ]);\n        watcher.dispose();\n        if (error)\n            throw error;\n    }\n    /**\n     * Adds a script tag into the current context.\n     *\n     * @remarks\n     *\n     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n     * in a browser environment you cannot pass a filepath and should use either\n     * `url` or `content`.\n     */\n    async addScriptTag(options) {\n        const { url = null, path = null, content = null, type = '' } = options;\n        if (url !== null) {\n            try {\n                const context = await this.executionContext();\n                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();\n            }\n            catch (error) {\n                throw new Error(`Loading script from ${url} failed`);\n            }\n        }\n        if (path !== null) {\n            if (!isNode) {\n                throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');\n            }\n            const fs = await helper.importFSModule();\n            let contents = await fs.promises.readFile(path, 'utf8');\n            contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();\n        }\n        if (content !== null) {\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();\n        }\n        throw new Error('Provide an object with a `url`, `path` or `content` property');\n        async function addScriptUrl(url, type) {\n            const script = document.createElement('script');\n            script.src = url;\n            if (type)\n                script.type = type;\n            const promise = new Promise((res, rej) => {\n                script.onload = res;\n                script.onerror = rej;\n            });\n            document.head.appendChild(script);\n            await promise;\n            return script;\n        }\n        function addScriptContent(content, type = 'text/javascript') {\n            const script = document.createElement('script');\n            script.type = type;\n            script.text = content;\n            let error = null;\n            script.onerror = (e) => (error = e);\n            document.head.appendChild(script);\n            if (error)\n                throw error;\n            return script;\n        }\n    }\n    /**\n     * Adds a style tag into the current context.\n     *\n     * @remarks\n     *\n     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n     * in a browser environment you cannot pass a filepath and should use either\n     * `url` or `content`.\n     *\n     */\n    async addStyleTag(options) {\n        const { url = null, path = null, content = null } = options;\n        if (url !== null) {\n            try {\n                const context = await this.executionContext();\n                return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n            }\n            catch (error) {\n                throw new Error(`Loading style from ${url} failed`);\n            }\n        }\n        if (path !== null) {\n            if (!isNode) {\n                throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');\n            }\n            const fs = await helper.importFSModule();\n            let contents = await fs.promises.readFile(path, 'utf8');\n            contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n        }\n        if (content !== null) {\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addStyleContent, content)).asElement();\n        }\n        throw new Error('Provide an object with a `url`, `path` or `content` property');\n        async function addStyleUrl(url) {\n            const link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.href = url;\n            const promise = new Promise((res, rej) => {\n                link.onload = res;\n                link.onerror = rej;\n            });\n            document.head.appendChild(link);\n            await promise;\n            return link;\n        }\n        async function addStyleContent(content) {\n            const style = document.createElement('style');\n            style.type = 'text/css';\n            style.appendChild(document.createTextNode(content));\n            const promise = new Promise((res, rej) => {\n                style.onload = res;\n                style.onerror = rej;\n            });\n            document.head.appendChild(style);\n            await promise;\n            return style;\n        }\n    }\n    async click(selector, options) {\n        const handle = await this.$(selector);\n        assert(handle, 'No node found for selector: ' + selector);\n        await handle.click(options);\n        await handle.dispose();\n    }\n    async focus(selector) {\n        const handle = await this.$(selector);\n        assert(handle, 'No node found for selector: ' + selector);\n        await handle.focus();\n        await handle.dispose();\n    }\n    async hover(selector) {\n        const handle = await this.$(selector);\n        assert(handle, 'No node found for selector: ' + selector);\n        await handle.hover();\n        await handle.dispose();\n    }\n    async select(selector, ...values) {\n        const handle = await this.$(selector);\n        assert(handle, 'No node found for selector: ' + selector);\n        const result = await handle.select(...values);\n        await handle.dispose();\n        return result;\n    }\n    async tap(selector) {\n        const handle = await this.$(selector);\n        await handle.tap();\n        await handle.dispose();\n    }\n    async type(selector, text, options) {\n        const handle = await this.$(selector);\n        assert(handle, 'No node found for selector: ' + selector);\n        await handle.type(text, options);\n        await handle.dispose();\n    }\n    async waitForSelector(selector, options) {\n        const { updatedSelector, queryHandler } = getQueryHandlerAndSelector(selector);\n        return queryHandler.waitFor(this, updatedSelector, options);\n    }\n    /**\n     * @internal\n     */\n    async addBindingToContext(context, name) {\n        // Previous operation added the binding so we are done.\n        if (this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {\n            return;\n        }\n        // Wait for other operation to finish\n        if (this._settingUpBinding) {\n            await this._settingUpBinding;\n            return this.addBindingToContext(context, name);\n        }\n        const bind = async (name) => {\n            const expression = helper.pageBindingInitString('internal', name);\n            try {\n                // TODO: In theory, it would be enough to call this just once\n                await context._client.send('Runtime.addBinding', {\n                    name,\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore The protocol definition is not up to date.\n                    executionContextName: context._contextName,\n                });\n                await context.evaluate(expression);\n            }\n            catch (error) {\n                // We could have tried to evaluate in a context which was already\n                // destroyed. This happens, for example, if the page is navigated while\n                // we are trying to add the binding\n                const ctxDestroyed = error.message.includes('Execution context was destroyed');\n                const ctxNotFound = error.message.includes('Cannot find context with specified id');\n                if (ctxDestroyed || ctxNotFound) {\n                    return;\n                }\n                else {\n                    debugError(error);\n                    return;\n                }\n            }\n            this._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));\n        };\n        this._settingUpBinding = bind(name);\n        await this._settingUpBinding;\n        this._settingUpBinding = null;\n    }\n    async _onBindingCalled(event) {\n        let payload;\n        if (!this._hasContext())\n            return;\n        const context = await this.executionContext();\n        try {\n            payload = JSON.parse(event.payload);\n        }\n        catch {\n            // The binding was either called by something in the page or it was\n            // called before our wrapper was initialized.\n            return;\n        }\n        const { type, name, seq, args } = payload;\n        if (type !== 'internal' ||\n            !this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId)))\n            return;\n        if (context._contextId !== event.executionContextId)\n            return;\n        try {\n            const result = await this._boundFunctions.get(name)(...args);\n            await context.evaluate(deliverResult, name, seq, result);\n        }\n        catch (error) {\n            // The WaitTask may already have been resolved by timing out, or the\n            // exection context may have been destroyed.\n            // In both caes, the promises above are rejected with a protocol error.\n            // We can safely ignores these, as the WaitTask is re-installed in\n            // the next execution context if needed.\n            if (error.message.includes('Protocol error'))\n                return;\n            debugError(error);\n        }\n        function deliverResult(name, seq, result) {\n            globalThis[name].callbacks.get(seq).resolve(result);\n            globalThis[name].callbacks.delete(seq);\n        }\n    }\n    /**\n     * @internal\n     */\n    async waitForSelectorInPage(queryOne, selector, options, binding) {\n        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;\n        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n        const title = `selector \\`${selector}\\`${waitForHidden ? ' to be hidden' : ''}`;\n        async function predicate(selector, waitForVisible, waitForHidden) {\n            const node = predicateQueryHandler\n                ? (await predicateQueryHandler(document, selector))\n                : document.querySelector(selector);\n            return checkWaitForOptions(node, waitForVisible, waitForHidden);\n        }\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: helper.makePredicateString(predicate, queryOne),\n            title,\n            polling,\n            timeout,\n            args: [selector, waitForVisible, waitForHidden],\n            binding,\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        const jsHandle = await waitTask.promise;\n        const elementHandle = jsHandle.asElement();\n        if (!elementHandle) {\n            await jsHandle.dispose();\n            return null;\n        }\n        return elementHandle;\n    }\n    async waitForXPath(xpath, options) {\n        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;\n        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n        const title = `XPath \\`${xpath}\\`${waitForHidden ? ' to be hidden' : ''}`;\n        function predicate(xpath, waitForVisible, waitForHidden) {\n            const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n            return checkWaitForOptions(node, waitForVisible, waitForHidden);\n        }\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: helper.makePredicateString(predicate),\n            title,\n            polling,\n            timeout,\n            args: [xpath, waitForVisible, waitForHidden],\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        const jsHandle = await waitTask.promise;\n        const elementHandle = jsHandle.asElement();\n        if (!elementHandle) {\n            await jsHandle.dispose();\n            return null;\n        }\n        return elementHandle;\n    }\n    waitForFunction(pageFunction, options = {}, ...args) {\n        const { polling = 'raf', timeout = this._timeoutSettings.timeout() } = options;\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: pageFunction,\n            title: 'function',\n            polling,\n            timeout,\n            args,\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        return waitTask.promise;\n    }\n    async title() {\n        return this.evaluate(() => document.title);\n    }\n}\nDOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;\n/**\n * @internal\n */\nexport class WaitTask {\n    constructor(options) {\n        this._runCount = 0;\n        this._terminated = false;\n        if (helper.isString(options.polling))\n            assert(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);\n        else if (helper.isNumber(options.polling))\n            assert(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);\n        else\n            throw new Error('Unknown polling options: ' + options.polling);\n        function getPredicateBody(predicateBody) {\n            if (helper.isString(predicateBody))\n                return `return (${predicateBody});`;\n            return `return (${predicateBody})(...args);`;\n        }\n        this._domWorld = options.domWorld;\n        this._polling = options.polling;\n        this._timeout = options.timeout;\n        this._predicateBody = getPredicateBody(options.predicateBody);\n        this._args = options.args;\n        this._binding = options.binding;\n        this._runCount = 0;\n        this._domWorld._waitTasks.add(this);\n        if (this._binding) {\n            this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);\n        }\n        this.promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        // Since page navigation requires us to re-install the pageScript, we should track\n        // timeout on our end.\n        if (options.timeout) {\n            const timeoutError = new TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);\n            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);\n        }\n        this.rerun();\n    }\n    terminate(error) {\n        this._terminated = true;\n        this._reject(error);\n        this._cleanup();\n    }\n    async rerun() {\n        const runCount = ++this._runCount;\n        let success = null;\n        let error = null;\n        const context = await this._domWorld.executionContext();\n        if (this._terminated || runCount !== this._runCount)\n            return;\n        if (this._binding) {\n            await this._domWorld.addBindingToContext(context, this._binding.name);\n        }\n        if (this._terminated || runCount !== this._runCount)\n            return;\n        try {\n            success = await context.evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n        }\n        catch (error_) {\n            error = error_;\n        }\n        if (this._terminated || runCount !== this._runCount) {\n            if (success)\n                await success.dispose();\n            return;\n        }\n        // Ignore timeouts in pageScript - we track timeouts ourselves.\n        // If the frame's execution context has already changed, `frame.evaluate` will\n        // throw an error - ignore this predicate run altogether.\n        if (!error &&\n            (await this._domWorld.evaluate((s) => !s, success).catch(() => true))) {\n            await success.dispose();\n            return;\n        }\n        if (error) {\n            if (error.message.includes('TypeError: binding is not a function')) {\n                return this.rerun();\n            }\n            // When frame is detached the task should have been terminated by the DOMWorld.\n            // This can fail if we were adding this task while the frame was detached,\n            // so we terminate here instead.\n            if (error.message.includes('Execution context is not available in detached frame')) {\n                this.terminate(new Error('waitForFunction failed: frame got detached.'));\n                return;\n            }\n            // When the page is navigated, the promise is rejected.\n            // We will try again in the new execution context.\n            if (error.message.includes('Execution context was destroyed'))\n                return;\n            // We could have tried to evaluate in a context which was already\n            // destroyed.\n            if (error.message.includes('Cannot find context with specified id'))\n                return;\n            this._reject(error);\n        }\n        else {\n            this._resolve(success);\n        }\n        this._cleanup();\n    }\n    _cleanup() {\n        clearTimeout(this._timeoutTimer);\n        this._domWorld._waitTasks.delete(this);\n    }\n}\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n    const predicate = new Function('...args', predicateBody);\n    let timedOut = false;\n    if (timeout)\n        setTimeout(() => (timedOut = true), timeout);\n    if (polling === 'raf')\n        return await pollRaf();\n    if (polling === 'mutation')\n        return await pollMutation();\n    if (typeof polling === 'number')\n        return await pollInterval(polling);\n    /**\n     * @returns {!Promise<*>}\n     */\n    async function pollMutation() {\n        const success = await predicate(...args);\n        if (success)\n            return Promise.resolve(success);\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        const observer = new MutationObserver(async () => {\n            if (timedOut) {\n                observer.disconnect();\n                fulfill();\n            }\n            const success = await predicate(...args);\n            if (success) {\n                observer.disconnect();\n                fulfill(success);\n            }\n        });\n        observer.observe(document, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n        });\n        return result;\n    }\n    async function pollRaf() {\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        await onRaf();\n        return result;\n        async function onRaf() {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const success = await predicate(...args);\n            if (success)\n                fulfill(success);\n            else\n                requestAnimationFrame(onRaf);\n        }\n    }\n    async function pollInterval(pollInterval) {\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        await onTimeout();\n        return result;\n        async function onTimeout() {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const success = await predicate(...args);\n            if (success)\n                fulfill(success);\n            else\n                setTimeout(onTimeout, pollInterval);\n        }\n    }\n}\n//# sourceMappingURL=DOMWorld.js.map"]},"metadata":{},"sourceType":"module"}