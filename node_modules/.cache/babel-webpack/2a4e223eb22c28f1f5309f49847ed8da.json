{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as os from 'os';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as util from 'util';\nimport * as childProcess from 'child_process';\nimport * as https from 'https';\nimport * as http from 'http';\nimport extractZip from 'extract-zip';\nimport { debug } from '../common/Debug.js';\nimport { promisify } from 'util';\nimport removeRecursive from 'rimraf';\nimport * as URL from 'url';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport { assert } from '../common/assert.js';\nconst debugFetcher = debug(`puppeteer:fetcher`);\nconst downloadURLs = {\n  chrome: {\n    linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n    mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n    win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n    win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip'\n  },\n  firefox: {\n    linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n    mac: '%s/firefox-%s.en-US.%s.dmg',\n    win32: '%s/firefox-%s.en-US.%s.zip',\n    win64: '%s/firefox-%s.en-US.%s.zip'\n  }\n};\nconst browserConfig = {\n  chrome: {\n    host: 'https://storage.googleapis.com',\n    destination: '.local-chromium'\n  },\n  firefox: {\n    host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',\n    destination: '.local-firefox'\n  }\n};\n\nfunction archiveName(product, platform, revision) {\n  if (product === 'chrome') {\n    if (platform === 'linux') return 'chrome-linux';\n    if (platform === 'mac') return 'chrome-mac';\n\n    if (platform === 'win32' || platform === 'win64') {\n      // Windows archive name changed at r591479.\n      return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';\n    }\n  } else if (product === 'firefox') {\n    return platform;\n  }\n}\n/**\n * @internal\n */\n\n\nfunction downloadURL(product, platform, host, revision) {\n  const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n  return url;\n}\n/**\n * @internal\n */\n\n\nfunction handleArm64() {\n  fs.stat('/usr/bin/chromium-browser', function (err, stats) {\n    if (stats === undefined) {\n      fs.stat('/usr/bin/chromium', function (err, stats) {\n        if (stats === undefined) {\n          console.error(`The chromium binary is not available for arm64.`);\n          console.error(`If you are on Ubuntu, you can install with: `);\n          console.error(`\\n sudo apt install chromium\\n`);\n          console.error(`\\n sudo apt install chromium-browser\\n`);\n          throw new Error();\n        }\n      });\n    }\n  });\n}\n\nconst readdirAsync = promisify(fs.readdir.bind(fs));\nconst mkdirAsync = promisify(fs.mkdir.bind(fs));\nconst unlinkAsync = promisify(fs.unlink.bind(fs));\nconst chmodAsync = promisify(fs.chmod.bind(fs));\n\nfunction existsAsync(filePath) {\n  return new Promise(resolve => {\n    fs.access(filePath, err => resolve(!err));\n  });\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `\"533271\"`. Revision strings can be obtained from {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}.\n * In the Firefox case, BrowserFetcher downloads Firefox Nightly and\n * operates on version numbers such as `\"75\"`.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```js\n * const browserFetcher = puppeteer.createBrowserFetcher();\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})\n * ```\n *\n * **NOTE** BrowserFetcher is not designed to work concurrently with other\n * instances of BrowserFetcher that share the same downloads directory.\n *\n * @public\n */\n\n\nexport class BrowserFetcher {\n  /**\n   * @internal\n   */\n  constructor(projectRoot, options = {}) {\n    this._product = (options.product || 'chrome').toLowerCase();\n    assert(this._product === 'chrome' || this._product === 'firefox', `Unknown product: \"${options.product}\"`);\n    this._downloadsFolder = options.path || path.join(projectRoot, browserConfig[this._product].destination);\n    this._downloadHost = options.host || browserConfig[this._product].host;\n    this.setPlatform(options.platform);\n    assert(downloadURLs[this._product][this._platform], 'Unsupported platform: ' + this._platform);\n  }\n\n  setPlatform(platformFromOptions) {\n    if (platformFromOptions) {\n      this._platform = platformFromOptions;\n      return;\n    }\n\n    const platform = os.platform();\n    if (platform === 'darwin') this._platform = 'mac';else if (platform === 'linux') this._platform = 'linux';else if (platform === 'win32') this._platform = os.arch() === 'x64' ? 'win64' : 'win32';else assert(this._platform, 'Unsupported platform: ' + os.platform());\n  }\n  /**\n   * @returns Returns the current `Platform`, which is one of `mac`, `linux`,\n   * `win32` or `win64`.\n   */\n\n\n  platform() {\n    return this._platform;\n  }\n  /**\n   * @returns Returns the current `Product`, which is one of `chrome` or\n   * `firefox`.\n   */\n\n\n  product() {\n    return this._product;\n  }\n  /**\n   * @returns The download host being used.\n   */\n\n\n  host() {\n    return this._downloadHost;\n  }\n  /**\n   * Initiates a HEAD request to check if the revision is available.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to check availability for.\n   * @returns A promise that resolves to `true` if the revision could be downloaded\n   * from the host.\n   */\n\n\n  canDownload(revision) {\n    const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n    return new Promise(resolve => {\n      const request = httpRequest(url, 'HEAD', response => {\n        resolve(response.statusCode === 200);\n      });\n      request.on('error', error => {\n        console.error(error);\n        resolve(false);\n      });\n    });\n  }\n  /**\n   * Initiates a GET request to download the revision from the host.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to download.\n   * @param progressCallback - A function that will be called with two arguments:\n   * How many bytes have been downloaded and the total number of bytes of the download.\n   * @returns A promise with revision information when the revision is downloaded\n   * and extracted.\n   */\n\n\n  download(revision, progressCallback = () => {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const url = downloadURL(_this._product, _this._platform, _this._downloadHost, revision);\n      const fileName = url.split('/').pop();\n      const archivePath = path.join(_this._downloadsFolder, fileName);\n\n      const outputPath = _this._getFolderPath(revision);\n\n      if (yield existsAsync(outputPath)) return _this.revisionInfo(revision);\n      if (!(yield existsAsync(_this._downloadsFolder))) yield mkdirAsync(_this._downloadsFolder); // Use Intel x86 builds on Apple M1 until native macOS arm64\n      // Chromium builds are available.\n\n      if (os.platform() !== 'darwin' && os.arch() === 'arm64') {\n        handleArm64();\n        return;\n      }\n\n      try {\n        yield downloadFile(url, archivePath, progressCallback);\n        yield install(archivePath, outputPath);\n      } finally {\n        if (yield existsAsync(archivePath)) yield unlinkAsync(archivePath);\n      }\n\n      const revisionInfo = _this.revisionInfo(revision);\n\n      if (revisionInfo) yield chmodAsync(revisionInfo.executablePath, 0o755);\n      return revisionInfo;\n    })();\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @returns A promise with a list of all revision strings (for the current `product`)\n   * available locally on disk.\n   */\n\n\n  localRevisions() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield existsAsync(_this2._downloadsFolder))) return [];\n      const fileNames = yield readdirAsync(_this2._downloadsFolder);\n      return fileNames.map(fileName => parseFolderPath(_this2._product, fileName)).filter(entry => entry && entry.platform === _this2._platform).map(entry => entry.revision);\n    })();\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - A revision to remove for the current `product`.\n   * @returns A promise that resolves when the revision has been removes or\n   * throws if the revision has not been downloaded.\n   */\n\n\n  remove(revision) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const folderPath = _this3._getFolderPath(revision);\n\n      assert(yield existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n      yield new Promise(fulfill => removeRecursive(folderPath, fulfill));\n    })();\n  }\n  /**\n   * @param revision - The revision to get info for.\n   * @returns The revision info for the given revision.\n   */\n\n\n  revisionInfo(revision) {\n    const folderPath = this._getFolderPath(revision);\n\n    let executablePath = '';\n\n    if (this._product === 'chrome') {\n      if (this._platform === 'mac') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');else if (this._platform === 'linux') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome');else if (this._platform === 'win32' || this._platform === 'win64') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome.exe');else throw new Error('Unsupported platform: ' + this._platform);\n    } else if (this._product === 'firefox') {\n      if (this._platform === 'mac') executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');else if (this._platform === 'linux') executablePath = path.join(folderPath, 'firefox', 'firefox');else if (this._platform === 'win32' || this._platform === 'win64') executablePath = path.join(folderPath, 'firefox', 'firefox.exe');else throw new Error('Unsupported platform: ' + this._platform);\n    } else {\n      throw new Error('Unsupported product: ' + this._product);\n    }\n\n    const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n    const local = fs.existsSync(folderPath);\n    debugFetcher({\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: this._product\n    });\n    return {\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: this._product\n    };\n  }\n  /**\n   * @internal\n   */\n\n\n  _getFolderPath(revision) {\n    return path.join(this._downloadsFolder, this._platform + '-' + revision);\n  }\n\n}\n\nfunction parseFolderPath(product, folderPath) {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) return null;\n  const [platform, revision] = splits;\n  if (!downloadURLs[product][platform]) return null;\n  return {\n    product,\n    platform,\n    revision\n  };\n}\n/**\n * @internal\n */\n\n\nfunction downloadFile(url, destinationPath, progressCallback) {\n  debugFetcher(`Downloading binary from ${url}`);\n  let fulfill, reject;\n  let downloadedBytes = 0;\n  let totalBytes = 0;\n  const promise = new Promise((x, y) => {\n    fulfill = x;\n    reject = y;\n  });\n  const request = httpRequest(url, 'GET', response => {\n    if (response.statusCode !== 200) {\n      const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`); // consume response data to free up memory\n\n      response.resume();\n      reject(error);\n      return;\n    }\n\n    const file = fs.createWriteStream(destinationPath);\n    file.on('finish', () => fulfill());\n    file.on('error', error => reject(error));\n    response.pipe(file);\n    totalBytes = parseInt(\n    /** @type {string} */\n    response.headers['content-length'], 10);\n    if (progressCallback) response.on('data', onData);\n  });\n  request.on('error', error => reject(error));\n  return promise;\n\n  function onData(chunk) {\n    downloadedBytes += chunk.length;\n    progressCallback(downloadedBytes, totalBytes);\n  }\n}\n\nfunction install(archivePath, folderPath) {\n  debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n  if (archivePath.endsWith('.zip')) return extractZip(archivePath, {\n    dir: folderPath\n  });else if (archivePath.endsWith('.tar.bz2')) return extractTar(archivePath, folderPath);else if (archivePath.endsWith('.dmg')) return mkdirAsync(folderPath).then(() => installDMG(archivePath, folderPath));else throw new Error(`Unsupported archive format: ${archivePath}`);\n}\n/**\n * @internal\n */\n\n\nfunction extractTar(tarPath, folderPath) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const tar = require('tar-fs'); // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n  const bzip = require('unbzip2-stream');\n\n  return new Promise((fulfill, reject) => {\n    const tarStream = tar.extract(folderPath);\n    tarStream.on('error', reject);\n    tarStream.on('finish', fulfill);\n    const readStream = fs.createReadStream(tarPath);\n    readStream.pipe(bzip()).pipe(tarStream);\n  });\n}\n/**\n * @internal\n */\n\n\nfunction installDMG(dmgPath, folderPath) {\n  let mountPath;\n\n  function mountAndCopy(fulfill, reject) {\n    const mountCommand = `hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`;\n    childProcess.exec(mountCommand, (err, stdout) => {\n      if (err) return reject(err);\n      const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n      if (!volumes) return reject(new Error(`Could not find volume path in ${stdout}`));\n      mountPath = volumes[0];\n      readdirAsync(mountPath).then(fileNames => {\n        const appName = fileNames.filter(item => typeof item === 'string' && item.endsWith('.app'))[0];\n        if (!appName) return reject(new Error(`Cannot find app in ${mountPath}`));\n        const copyPath = path.join(mountPath, appName);\n        debugFetcher(`Copying ${copyPath} to ${folderPath}`);\n        childProcess.exec(`cp -R \"${copyPath}\" \"${folderPath}\"`, err => {\n          if (err) reject(err);else fulfill();\n        });\n      }).catch(reject);\n    });\n  }\n\n  function unmount() {\n    if (!mountPath) return;\n    const unmountCommand = `hdiutil detach \"${mountPath}\" -quiet`;\n    debugFetcher(`Unmounting ${mountPath}`);\n    childProcess.exec(unmountCommand, err => {\n      if (err) console.error(`Error unmounting dmg: ${err}`);\n    });\n  }\n\n  return new Promise(mountAndCopy).catch(error => {\n    console.error(error);\n  }).finally(unmount);\n}\n\nfunction httpRequest(url, method, response) {\n  const urlParsed = URL.parse(url);\n  let options = { ...urlParsed,\n    method\n  };\n  const proxyURL = getProxyForUrl(url);\n\n  if (proxyURL) {\n    if (url.startsWith('http:')) {\n      const proxy = URL.parse(proxyURL);\n      options = {\n        path: options.href,\n        host: proxy.hostname,\n        port: proxy.port\n      };\n    } else {\n      const parsedProxyURL = URL.parse(proxyURL);\n      const proxyOptions = { ...parsedProxyURL,\n        secureProxy: parsedProxyURL.protocol === 'https:'\n      };\n      options.agent = createHttpsProxyAgent(proxyOptions);\n      options.rejectUnauthorized = false;\n    }\n  }\n\n  const requestCallback = res => {\n    if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) httpRequest(res.headers.location, method, response);else response(res);\n  };\n\n  const request = options.protocol === 'https:' ? https.request(options, requestCallback) : http.request(options, requestCallback);\n  request.end();\n  return request;\n} //# sourceMappingURL=BrowserFetcher.js.map","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/node/BrowserFetcher.js"],"names":["os","fs","path","util","childProcess","https","http","extractZip","debug","promisify","removeRecursive","URL","createHttpsProxyAgent","getProxyForUrl","assert","debugFetcher","downloadURLs","chrome","linux","mac","win32","win64","firefox","browserConfig","host","destination","archiveName","product","platform","revision","parseInt","downloadURL","url","format","handleArm64","stat","err","stats","undefined","console","error","Error","readdirAsync","readdir","bind","mkdirAsync","mkdir","unlinkAsync","unlink","chmodAsync","chmod","existsAsync","filePath","Promise","resolve","access","BrowserFetcher","constructor","projectRoot","options","_product","toLowerCase","_downloadsFolder","join","_downloadHost","setPlatform","_platform","platformFromOptions","arch","canDownload","request","httpRequest","response","statusCode","on","download","progressCallback","fileName","split","pop","archivePath","outputPath","_getFolderPath","revisionInfo","downloadFile","install","executablePath","localRevisions","fileNames","map","parseFolderPath","filter","entry","remove","folderPath","fulfill","local","existsSync","name","basename","splits","length","destinationPath","reject","downloadedBytes","totalBytes","promise","x","y","resume","file","createWriteStream","pipe","headers","onData","chunk","endsWith","dir","extractTar","then","installDMG","tarPath","tar","require","bzip","tarStream","extract","readStream","createReadStream","dmgPath","mountPath","mountAndCopy","mountCommand","exec","stdout","volumes","match","appName","item","copyPath","catch","unmount","unmountCommand","finally","method","urlParsed","parse","proxyURL","startsWith","proxy","href","hostname","port","parsedProxyURL","proxyOptions","secureProxy","protocol","agent","rejectUnauthorized","requestCallback","res","location","end"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as os from 'os';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as util from 'util';\nimport * as childProcess from 'child_process';\nimport * as https from 'https';\nimport * as http from 'http';\nimport extractZip from 'extract-zip';\nimport { debug } from '../common/Debug.js';\nimport { promisify } from 'util';\nimport removeRecursive from 'rimraf';\nimport * as URL from 'url';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport { assert } from '../common/assert.js';\nconst debugFetcher = debug(`puppeteer:fetcher`);\nconst downloadURLs = {\n    chrome: {\n        linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n        mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n        win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n        win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip',\n    },\n    firefox: {\n        linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n        mac: '%s/firefox-%s.en-US.%s.dmg',\n        win32: '%s/firefox-%s.en-US.%s.zip',\n        win64: '%s/firefox-%s.en-US.%s.zip',\n    },\n};\nconst browserConfig = {\n    chrome: {\n        host: 'https://storage.googleapis.com',\n        destination: '.local-chromium',\n    },\n    firefox: {\n        host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',\n        destination: '.local-firefox',\n    },\n};\nfunction archiveName(product, platform, revision) {\n    if (product === 'chrome') {\n        if (platform === 'linux')\n            return 'chrome-linux';\n        if (platform === 'mac')\n            return 'chrome-mac';\n        if (platform === 'win32' || platform === 'win64') {\n            // Windows archive name changed at r591479.\n            return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';\n        }\n    }\n    else if (product === 'firefox') {\n        return platform;\n    }\n}\n/**\n * @internal\n */\nfunction downloadURL(product, platform, host, revision) {\n    const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n    return url;\n}\n/**\n * @internal\n */\nfunction handleArm64() {\n    fs.stat('/usr/bin/chromium-browser', function (err, stats) {\n        if (stats === undefined) {\n            fs.stat('/usr/bin/chromium', function (err, stats) {\n                if (stats === undefined) {\n                    console.error(`The chromium binary is not available for arm64.`);\n                    console.error(`If you are on Ubuntu, you can install with: `);\n                    console.error(`\\n sudo apt install chromium\\n`);\n                    console.error(`\\n sudo apt install chromium-browser\\n`);\n                    throw new Error();\n                }\n            });\n        }\n    });\n}\nconst readdirAsync = promisify(fs.readdir.bind(fs));\nconst mkdirAsync = promisify(fs.mkdir.bind(fs));\nconst unlinkAsync = promisify(fs.unlink.bind(fs));\nconst chmodAsync = promisify(fs.chmod.bind(fs));\nfunction existsAsync(filePath) {\n    return new Promise((resolve) => {\n        fs.access(filePath, (err) => resolve(!err));\n    });\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `\"533271\"`. Revision strings can be obtained from {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}.\n * In the Firefox case, BrowserFetcher downloads Firefox Nightly and\n * operates on version numbers such as `\"75\"`.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```js\n * const browserFetcher = puppeteer.createBrowserFetcher();\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})\n * ```\n *\n * **NOTE** BrowserFetcher is not designed to work concurrently with other\n * instances of BrowserFetcher that share the same downloads directory.\n *\n * @public\n */\nexport class BrowserFetcher {\n    /**\n     * @internal\n     */\n    constructor(projectRoot, options = {}) {\n        this._product = (options.product || 'chrome').toLowerCase();\n        assert(this._product === 'chrome' || this._product === 'firefox', `Unknown product: \"${options.product}\"`);\n        this._downloadsFolder =\n            options.path ||\n                path.join(projectRoot, browserConfig[this._product].destination);\n        this._downloadHost = options.host || browserConfig[this._product].host;\n        this.setPlatform(options.platform);\n        assert(downloadURLs[this._product][this._platform], 'Unsupported platform: ' + this._platform);\n    }\n    setPlatform(platformFromOptions) {\n        if (platformFromOptions) {\n            this._platform = platformFromOptions;\n            return;\n        }\n        const platform = os.platform();\n        if (platform === 'darwin')\n            this._platform = 'mac';\n        else if (platform === 'linux')\n            this._platform = 'linux';\n        else if (platform === 'win32')\n            this._platform = os.arch() === 'x64' ? 'win64' : 'win32';\n        else\n            assert(this._platform, 'Unsupported platform: ' + os.platform());\n    }\n    /**\n     * @returns Returns the current `Platform`, which is one of `mac`, `linux`,\n     * `win32` or `win64`.\n     */\n    platform() {\n        return this._platform;\n    }\n    /**\n     * @returns Returns the current `Product`, which is one of `chrome` or\n     * `firefox`.\n     */\n    product() {\n        return this._product;\n    }\n    /**\n     * @returns The download host being used.\n     */\n    host() {\n        return this._downloadHost;\n    }\n    /**\n     * Initiates a HEAD request to check if the revision is available.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to check availability for.\n     * @returns A promise that resolves to `true` if the revision could be downloaded\n     * from the host.\n     */\n    canDownload(revision) {\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        return new Promise((resolve) => {\n            const request = httpRequest(url, 'HEAD', (response) => {\n                resolve(response.statusCode === 200);\n            });\n            request.on('error', (error) => {\n                console.error(error);\n                resolve(false);\n            });\n        });\n    }\n    /**\n     * Initiates a GET request to download the revision from the host.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to download.\n     * @param progressCallback - A function that will be called with two arguments:\n     * How many bytes have been downloaded and the total number of bytes of the download.\n     * @returns A promise with revision information when the revision is downloaded\n     * and extracted.\n     */\n    async download(revision, progressCallback = () => { }) {\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        const fileName = url.split('/').pop();\n        const archivePath = path.join(this._downloadsFolder, fileName);\n        const outputPath = this._getFolderPath(revision);\n        if (await existsAsync(outputPath))\n            return this.revisionInfo(revision);\n        if (!(await existsAsync(this._downloadsFolder)))\n            await mkdirAsync(this._downloadsFolder);\n        // Use Intel x86 builds on Apple M1 until native macOS arm64\n        // Chromium builds are available.\n        if (os.platform() !== 'darwin' && os.arch() === 'arm64') {\n            handleArm64();\n            return;\n        }\n        try {\n            await downloadFile(url, archivePath, progressCallback);\n            await install(archivePath, outputPath);\n        }\n        finally {\n            if (await existsAsync(archivePath))\n                await unlinkAsync(archivePath);\n        }\n        const revisionInfo = this.revisionInfo(revision);\n        if (revisionInfo)\n            await chmodAsync(revisionInfo.executablePath, 0o755);\n        return revisionInfo;\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @returns A promise with a list of all revision strings (for the current `product`)\n     * available locally on disk.\n     */\n    async localRevisions() {\n        if (!(await existsAsync(this._downloadsFolder)))\n            return [];\n        const fileNames = await readdirAsync(this._downloadsFolder);\n        return fileNames\n            .map((fileName) => parseFolderPath(this._product, fileName))\n            .filter((entry) => entry && entry.platform === this._platform)\n            .map((entry) => entry.revision);\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - A revision to remove for the current `product`.\n     * @returns A promise that resolves when the revision has been removes or\n     * throws if the revision has not been downloaded.\n     */\n    async remove(revision) {\n        const folderPath = this._getFolderPath(revision);\n        assert(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n        await new Promise((fulfill) => removeRecursive(folderPath, fulfill));\n    }\n    /**\n     * @param revision - The revision to get info for.\n     * @returns The revision info for the given revision.\n     */\n    revisionInfo(revision) {\n        const folderPath = this._getFolderPath(revision);\n        let executablePath = '';\n        if (this._product === 'chrome') {\n            if (this._platform === 'mac')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');\n            else if (this._platform === 'linux')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome');\n            else if (this._platform === 'win32' || this._platform === 'win64')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome.exe');\n            else\n                throw new Error('Unsupported platform: ' + this._platform);\n        }\n        else if (this._product === 'firefox') {\n            if (this._platform === 'mac')\n                executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');\n            else if (this._platform === 'linux')\n                executablePath = path.join(folderPath, 'firefox', 'firefox');\n            else if (this._platform === 'win32' || this._platform === 'win64')\n                executablePath = path.join(folderPath, 'firefox', 'firefox.exe');\n            else\n                throw new Error('Unsupported platform: ' + this._platform);\n        }\n        else {\n            throw new Error('Unsupported product: ' + this._product);\n        }\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        const local = fs.existsSync(folderPath);\n        debugFetcher({\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: this._product,\n        });\n        return {\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: this._product,\n        };\n    }\n    /**\n     * @internal\n     */\n    _getFolderPath(revision) {\n        return path.join(this._downloadsFolder, this._platform + '-' + revision);\n    }\n}\nfunction parseFolderPath(product, folderPath) {\n    const name = path.basename(folderPath);\n    const splits = name.split('-');\n    if (splits.length !== 2)\n        return null;\n    const [platform, revision] = splits;\n    if (!downloadURLs[product][platform])\n        return null;\n    return { product, platform, revision };\n}\n/**\n * @internal\n */\nfunction downloadFile(url, destinationPath, progressCallback) {\n    debugFetcher(`Downloading binary from ${url}`);\n    let fulfill, reject;\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n    const promise = new Promise((x, y) => {\n        fulfill = x;\n        reject = y;\n    });\n    const request = httpRequest(url, 'GET', (response) => {\n        if (response.statusCode !== 200) {\n            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n            // consume response data to free up memory\n            response.resume();\n            reject(error);\n            return;\n        }\n        const file = fs.createWriteStream(destinationPath);\n        file.on('finish', () => fulfill());\n        file.on('error', (error) => reject(error));\n        response.pipe(file);\n        totalBytes = parseInt(\n        /** @type {string} */ response.headers['content-length'], 10);\n        if (progressCallback)\n            response.on('data', onData);\n    });\n    request.on('error', (error) => reject(error));\n    return promise;\n    function onData(chunk) {\n        downloadedBytes += chunk.length;\n        progressCallback(downloadedBytes, totalBytes);\n    }\n}\nfunction install(archivePath, folderPath) {\n    debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n    if (archivePath.endsWith('.zip'))\n        return extractZip(archivePath, { dir: folderPath });\n    else if (archivePath.endsWith('.tar.bz2'))\n        return extractTar(archivePath, folderPath);\n    else if (archivePath.endsWith('.dmg'))\n        return mkdirAsync(folderPath).then(() => installDMG(archivePath, folderPath));\n    else\n        throw new Error(`Unsupported archive format: ${archivePath}`);\n}\n/**\n * @internal\n */\nfunction extractTar(tarPath, folderPath) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const tar = require('tar-fs');\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const bzip = require('unbzip2-stream');\n    return new Promise((fulfill, reject) => {\n        const tarStream = tar.extract(folderPath);\n        tarStream.on('error', reject);\n        tarStream.on('finish', fulfill);\n        const readStream = fs.createReadStream(tarPath);\n        readStream.pipe(bzip()).pipe(tarStream);\n    });\n}\n/**\n * @internal\n */\nfunction installDMG(dmgPath, folderPath) {\n    let mountPath;\n    function mountAndCopy(fulfill, reject) {\n        const mountCommand = `hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`;\n        childProcess.exec(mountCommand, (err, stdout) => {\n            if (err)\n                return reject(err);\n            const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n            if (!volumes)\n                return reject(new Error(`Could not find volume path in ${stdout}`));\n            mountPath = volumes[0];\n            readdirAsync(mountPath)\n                .then((fileNames) => {\n                const appName = fileNames.filter((item) => typeof item === 'string' && item.endsWith('.app'))[0];\n                if (!appName)\n                    return reject(new Error(`Cannot find app in ${mountPath}`));\n                const copyPath = path.join(mountPath, appName);\n                debugFetcher(`Copying ${copyPath} to ${folderPath}`);\n                childProcess.exec(`cp -R \"${copyPath}\" \"${folderPath}\"`, (err) => {\n                    if (err)\n                        reject(err);\n                    else\n                        fulfill();\n                });\n            })\n                .catch(reject);\n        });\n    }\n    function unmount() {\n        if (!mountPath)\n            return;\n        const unmountCommand = `hdiutil detach \"${mountPath}\" -quiet`;\n        debugFetcher(`Unmounting ${mountPath}`);\n        childProcess.exec(unmountCommand, (err) => {\n            if (err)\n                console.error(`Error unmounting dmg: ${err}`);\n        });\n    }\n    return new Promise(mountAndCopy)\n        .catch((error) => {\n        console.error(error);\n    })\n        .finally(unmount);\n}\nfunction httpRequest(url, method, response) {\n    const urlParsed = URL.parse(url);\n    let options = {\n        ...urlParsed,\n        method,\n    };\n    const proxyURL = getProxyForUrl(url);\n    if (proxyURL) {\n        if (url.startsWith('http:')) {\n            const proxy = URL.parse(proxyURL);\n            options = {\n                path: options.href,\n                host: proxy.hostname,\n                port: proxy.port,\n            };\n        }\n        else {\n            const parsedProxyURL = URL.parse(proxyURL);\n            const proxyOptions = {\n                ...parsedProxyURL,\n                secureProxy: parsedProxyURL.protocol === 'https:',\n            };\n            options.agent = createHttpsProxyAgent(proxyOptions);\n            options.rejectUnauthorized = false;\n        }\n    }\n    const requestCallback = (res) => {\n        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)\n            httpRequest(res.headers.location, method, response);\n        else\n            response(res);\n    };\n    const request = options.protocol === 'https:'\n        ? https.request(options, requestCallback)\n        : http.request(options, requestCallback);\n    request.end();\n    return request;\n}\n//# sourceMappingURL=BrowserFetcher.js.map"]},"metadata":{},"sourceType":"module"}