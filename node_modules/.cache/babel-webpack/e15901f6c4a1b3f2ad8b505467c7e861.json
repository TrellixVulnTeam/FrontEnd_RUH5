{"ast":null,"code":"import _asyncToGenerator from \"/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction queryAXTree(_x, _x2, _x3, _x4) {\n  return _queryAXTree.apply(this, arguments);\n}\n\nfunction _queryAXTree() {\n  _queryAXTree = _asyncToGenerator(function* (client, element, accessibleName, role) {\n    const {\n      nodes\n    } = yield client.send('Accessibility.queryAXTree', {\n      objectId: element._remoteObject.objectId,\n      accessibleName,\n      role\n    });\n    const filteredNodes = nodes.filter(node => node.role.value !== 'StaticText');\n    return filteredNodes;\n  });\n  return _queryAXTree.apply(this, arguments);\n}\n\nfunction parseAriaSelector(selector) {\n  const normalize = value => value.replace(/ +/g, ' ').trim();\n\n  const knownAttributes = new Set(['name', 'role']);\n  const queryOptions = {};\n  const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/g;\n  const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n    attribute = attribute.trim();\n    if (!knownAttributes.has(attribute)) throw new Error(`Unknown aria attribute \"${attribute}\" in selector`);\n    queryOptions[attribute] = normalize(value);\n    return '';\n  });\n  if (defaultName && !queryOptions.name) queryOptions.name = normalize(defaultName);\n  return queryOptions;\n}\n\nconst queryOne = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (element, selector) {\n    const exeCtx = element.executionContext();\n    const {\n      name,\n      role\n    } = parseAriaSelector(selector);\n    const res = yield queryAXTree(exeCtx._client, element, name, role);\n\n    if (res.length < 1) {\n      return null;\n    }\n\n    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n  });\n\n  return function queryOne(_x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst waitFor = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (domWorld, selector, options) {\n    const binding = {\n      name: 'ariaQuerySelector',\n      pptrFunction: function () {\n        var _ref3 = _asyncToGenerator(function* (selector) {\n          const document = yield domWorld._document();\n          const element = yield queryOne(document, selector);\n          return element;\n        });\n\n        return function pptrFunction(_x10) {\n          return _ref3.apply(this, arguments);\n        };\n      }()\n    };\n    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n  });\n\n  return function waitFor(_x7, _x8, _x9) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst queryAll = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (element, selector) {\n    const exeCtx = element.executionContext();\n    const {\n      name,\n      role\n    } = parseAriaSelector(selector);\n    const res = yield queryAXTree(exeCtx._client, element, name, role);\n    return Promise.all(res.map(axNode => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n  });\n\n  return function queryAll(_x11, _x12) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nconst queryAllArray = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (element, selector) {\n    const elementHandles = yield queryAll(element, selector);\n    const exeCtx = element.executionContext();\n    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n    return jsHandle;\n  });\n\n  return function queryAllArray(_x13, _x14) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n/**\n * @internal\n */\n\n\nexport const ariaHandler = {\n  queryOne,\n  waitFor,\n  queryAll,\n  queryAllArray\n}; //# sourceMappingURL=AriaQueryHandler.js.map","map":{"version":3,"sources":["/Users/khangtran/Documents/GitHub/FrontEnd/node_modules/puppeteer/lib/esm/puppeteer/common/AriaQueryHandler.js"],"names":["queryAXTree","client","element","accessibleName","role","nodes","send","objectId","_remoteObject","filteredNodes","filter","node","value","parseAriaSelector","selector","normalize","replace","trim","knownAttributes","Set","queryOptions","attributeRegexp","defaultName","_","attribute","has","Error","name","queryOne","exeCtx","executionContext","res","_client","length","_adoptBackendNodeId","backendDOMNodeId","waitFor","domWorld","options","binding","pptrFunction","document","_document","waitForSelectorInPage","globalThis","ariaQuerySelector","queryAll","Promise","all","map","axNode","queryAllArray","elementHandles","jsHandle","evaluateHandle","elements","ariaHandler"],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function queryAXTree(client, element, accessibleName, role) {\n    const { nodes } = await client.send('Accessibility.queryAXTree', {\n        objectId: element._remoteObject.objectId,\n        accessibleName,\n        role,\n    });\n    const filteredNodes = nodes.filter((node) => node.role.value !== 'StaticText');\n    return filteredNodes;\n}\nfunction parseAriaSelector(selector) {\n    const normalize = (value) => value.replace(/ +/g, ' ').trim();\n    const knownAttributes = new Set(['name', 'role']);\n    const queryOptions = {};\n    const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/g;\n    const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n        attribute = attribute.trim();\n        if (!knownAttributes.has(attribute))\n            throw new Error(`Unknown aria attribute \"${attribute}\" in selector`);\n        queryOptions[attribute] = normalize(value);\n        return '';\n    });\n    if (defaultName && !queryOptions.name)\n        queryOptions.name = normalize(defaultName);\n    return queryOptions;\n}\nconst queryOne = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    if (res.length < 1) {\n        return null;\n    }\n    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n};\nconst waitFor = async (domWorld, selector, options) => {\n    const binding = {\n        name: 'ariaQuerySelector',\n        pptrFunction: async (selector) => {\n            const document = await domWorld._document();\n            const element = await queryOne(document, selector);\n            return element;\n        },\n    };\n    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n};\nconst queryAll = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    return Promise.all(res.map((axNode) => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n};\nconst queryAllArray = async (element, selector) => {\n    const elementHandles = await queryAll(element, selector);\n    const exeCtx = element.executionContext();\n    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n    return jsHandle;\n};\n/**\n * @internal\n */\nexport const ariaHandler = {\n    queryOne,\n    waitFor,\n    queryAll,\n    queryAllArray,\n};\n//# sourceMappingURL=AriaQueryHandler.js.map"]},"metadata":{},"sourceType":"module"}